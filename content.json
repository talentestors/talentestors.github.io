{"meta":{"title":"終わり群星 | Home","subtitle":"欢迎来到 My Blog!","description":"愿此行，终抵群星！","author":"talentestors","url":"http://yuhiri.me","root":"/"},"pages":[{"title":"","date":"2026-01-07T04:51:20.307Z","updated":"2026-01-07T04:51:20.307Z","comments":true,"path":"giscus.json","permalink":"http://yuhiri.me/giscus.json","excerpt":"","text":"{\"origins\":[\"https://yuhiri.me\",\"https://talentestors.github.io\"],\"originsRegex\":\"(https://|http://)([a-zA-Z0-9-_]\\\\.)*yuhiri\\\\.(me|top)+\",\"defaultCommentOrder\":\"newest\"}"},{"title":"about","date":"2022-12-12T14:14:36.000Z","updated":"2026-01-05T13:44:37.044Z","comments":false,"path":"about/index.html","permalink":"http://yuhiri.me/about/index.html","excerpt":"","text":""},{"title":"bangumis","date":"2025-03-23T07:09:14.000Z","updated":"2025-03-23T07:51:37.729Z","comments":false,"path":"bangumis/index.html","permalink":"http://yuhiri.me/bangumis/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2024-05-02T14:01:09.906Z","comments":true,"path":"comment/index.html","permalink":"http://yuhiri.me/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2024-05-02T14:01:13.336Z","comments":false,"path":"donate/index.html","permalink":"http://yuhiri.me/donate/index.html","excerpt":"","text":""},{"title":"bangumi","date":"2023-04-17T13:32:48.000Z","updated":"2025-09-27T06:46:09.846Z","comments":false,"path":"bangumi/index.html","permalink":"http://yuhiri.me/bangumi/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2026-01-05T13:41:23.608Z","comments":true,"path":"lab/index.html","permalink":"http://yuhiri.me/lab/index.html","excerpt":"","text":"Chat 测试 目前暂停服务 暂停中 😢 点我进行访问 需要申请体验的，发送邮件至talentestors@outlook.com 可获取临时访问密码。😊 Bing AI测试 目前暂停服务 fancy-box 相册功能测试 B 站视频测试"},{"title":"images","date":"2023-05-18T03:01:31.000Z","updated":"2025-04-05T13:08:54.470Z","comments":false,"path":"images/index.html","permalink":"http://yuhiri.me/images/index.html","excerpt":"","text":".site-content { max-width: 950px !important; } .site-content br { display: none; } .site-content article { display: flex !important; flex-wrap: wrap !important; justify-content: center !important; align-items: center !important; } .site-content img { max-width: 300px !important; height: auto !important; margin: 1px !important; }"},{"title":"links","date":"2022-12-19T15:11:06.000Z","updated":"2026-01-05T13:35:57.386Z","comments":true,"path":"links/index.html","permalink":"http://yuhiri.me/links/index.html","excerpt":"","text":""},{"title":"rss","date":"2022-12-20T15:09:03.000Z","updated":"2024-03-06T09:14:58.272Z","comments":true,"path":"rss/index.html","permalink":"http://yuhiri.me/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2022-12-20T15:14:28.000Z","updated":"2024-12-26T05:02:05.220Z","comments":true,"path":"music/index.html","permalink":"http://yuhiri.me/music/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2023-05-04T14:53:25.000Z","updated":"2024-12-25T17:07:37.588Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://yuhiri.me/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro 2024/12/21 升级到 hexo 7.0 fancybox 渲染 美化表格样式 美化代码块 添加标签云 优化目录 更新依赖 添加 utteranc 评论系统 添加 giscus 评论系统"},{"title":"tags","date":"2022-12-12T14:14:16.000Z","updated":"2024-12-21T08:16:24.756Z","comments":false,"path":"tags/index.html","permalink":"http://yuhiri.me/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2024-03-06T09:14:58.273Z","comments":false,"path":"video/index.html","permalink":"http://yuhiri.me/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"2025 年度总结：从技术追随者到开源贡献者的蜕变之旅","slug":"2025-summary","date":"2026-01-01T16:26:59.000Z","updated":"2026-01-06T08:21:20.272Z","comments":true,"path":"2026/01/02/2025-summary/","permalink":"http://yuhiri.me/2026/01/02/2025-summary/","excerpt":"","text":"数字足迹，成长印记 2025 年，咱的技术旅程画出了一条清晰的上升轨迹。从 GitHub 贡献热力图可见，352 次提交悄悄记录了 365 天的成长故事，而最活跃的 12 月，就像年终给自己放的一场代码烟花~🎇 每个星期四的夜晚，当城市的喧嚣渐渐安静下来，键盘的敲击声却在为属于咱的数字世界谱写着小夜曲。 站在 2026 年的起点回望，这一年最最深刻的转变是：咱从一个默默学习技术的小伙伴，变成了一位能真正为开源世界添砖加瓦的小小贡献者。技术栈从一棵小树苗长出了好多枝丫，责任从个人小项目延伸到了社区大家庭，视野也从一行行代码，慢慢看到了整个系统星空呢！✨ 一、开源生态 2025 年，咱的开源小脚印走到了好多有趣的技术社区： NoneBot2：从使用者变成了小帮手，核心插件还被官方商店收藏啦！ OpenListTeam：有幸参与并见证了 OpenList 项目新分支的诞生，还提交过详细的 bug 分析哦。 ChatGPTNextWeb：帮忙捉过虫虫（bug）~ GetZep：在 PostgreSQL AGV 的生态里玩耍学习 这种深度参与不仅仅是技术力的证明，更像是一颗小种子，在心里悄悄种下了开源精神的基因。当看到自己写的代码被集成到世界各地开发者的项目里，那种“被需要”和“被连接”的感觉，真的比代码运行成功还要温暖！🌱 二、基础设施 在云上筑起自己的小天地，自主掌控的感觉真好呀~ 雨云服务器 2025 年，咱在雨云上拥有了人生第一台云服务器，这标志着技术自主权的大门真正向咱打开啦： 初始配置：2 核 2G 内存 + 30GB 存储 + 50M 带宽 升级配置：2 核 4G 内存 + 30GB 固态 + 10GB 机械 + 50M 带宽 地理位置：香港 IP 节点 系统环境：Debian 13 在这台小服务器上，咱搭建了一个完整的自托管技术生态小世界： ├── OI-Bot：算法竞赛小助手（Python/NoneBot2） ├── NapCat：QQ机器人协议实现 ├── NewAPI：自定义API网关 ├── OpenList：开源列表管理 ├── 中间件层 │ ├── OpenResty（Nginx + Lua） │ ├── PostgreSQL（万能数据库，数据库的终极！） │ └── Redis（缓存加速小能手） 这种全栈式部署不仅锻炼了咱运维的动手能力，更让咱慢慢理解了系统之间“手拉手”和“独立玩耍”的小哲学呢~ 服务监控：Uptime Kuma 守护数字资产 借助雨云的云应用生态，咱基于 Kuma Uptime 搭建了服务监控站点：https://status.yuhiri.me。 这个监控面板就像一个小卫士，不仅保障了服务的稳定可靠，更让咱明白了“可观测性”在复杂系统里是多么重要的眼睛。👀 三、数字资产：域名与品牌建设 2025 年，咱在 SpaceShip 领养了两个重要的域名小伙伴： yuhiri.me：个人技术品牌的小家门 yuhiri.top：备用小门和实验项目的游乐园 这两个域名不仅统一了在线身份，更像两颗小基石，为 2026 年的新征程铺好了小路。 全面掌控数字资产的感觉真好：域名就是数字时代最最基础的身份小徽章呀。 四、Astro：岛屿架构的技术启示 2025 年最让咱兴奋的技术发现无疑是 Astro 框架及其革命性的岛屿架构（Islands Architecture）。当咱深入研读官方文档后，才真正体会到这种架构设计的精妙之处。 岛屿架构的核心思想 Astro 默认生成零客户端 JavaScript 的网站，这是一个颠覆性的设计理念。通过岛屿架构，Astro 将页面分解为多个独立的交互单元（“岛屿”），每个岛屿只在需要时加载和激活，实现了极致的性能优化。 多框架融合的魔法☆Magic 最让我惊叹的是 Astro 对多框架的无缝支持。在同一个项目中，咱可以自由使用 React、Vue、Svelte 甚至 Web Components 体系的魔法。 ／人◕ ‿‿ ◕人＼／人∩ ‿‿ ∩人＼ 与我签订契约 成为魔法少女吧！ 这种框架无关的设计让技术选型不再成为团队协作的障碍，每个开发者都可以使用自己最熟悉的工具。 --- // 在同一个Astro页面中混用不同框架 import ReactCounter from '../components/ReactCounter.jsx'; import VueChart from '../components/VueChart.vue'; import SvelteSlider from '../components/SvelteSlider.svelte'; --- &lt;ReactCounter client:visible /&gt; &lt;VueChart client:load /&gt; &lt;SvelteSlider client:idle /&gt; 岛屿架构的真正威力在于，当需要更换技术栈时，只需要进行文件级别的修改，而不需要重写整个应用。这种渐进式迁移的能力让技术债务管理变得前所未有的简单。 五、OI-Bot 与开源贡献 OI-Bot：从痛点出发，为社区创造价值 GitHub 仓库: https://github.com/talentestors/OI-Bot/ 作为本校首支 ACM 校队的小成员，咱深深体会到信息不畅通对竞赛训练的困扰。2023 年至今，咱主导设计并开发了 OI-Bot 开源机器人，基于 Python/NoneBot2 异步框架，深度整合了 Clist.by 等 10 多个竞赛平台的 API，为团队提供精准、实时的赛程与题目数据支持。 技术亮点： 模块化架构：把核心功能变成一个个独立的插件小积木 nonebot-plugin-oi-helper 容器化部署：用 Docker 实现环境一致性，打包带走~ 自动化流程：通过 GitHub Actions 实现 CI/CD，自动化小助手 社区影响：服务 5+个 QQ 群，每天被查询 50+次，被需要的感觉真好！ nonebot-plugin-oi-helper GitHub 仓库: https://github.com/talentestors/nonebot-plugin-oi-helper 2025 年最让咱开心的技术突破，就是把 OI-Bot 的核心功能打包发布成了标准库： PyPI 发布：https://pypi.org/project/nonebot-plugin-oi-helper/ 官方收录：被 NoneBot2 官方商店“收留”啦！ 技术价值：基于 Clist.by v4 API 开发，符合 NoneBot2 插件规范 这个过程让咱完整经历了一个开源库从设计、开发、测试、发布到维护的全生命周期，是技术成长路上一个亮闪闪的小里程碑呢！🌟 六、职业发展：意外与成长 秋招奇遇：一次面试定终身 2025 年暑假，咱全身心投入 ACM 竞赛准备，完全错过了秋招黄金期。当意识到需要找工作时，秋招已经接近尾声啦。匆忙基于 LaTeX 模板修改了简历，海投一周后，竟然意外获得了人生第一个面试机会！ 本以为第一次面试会经验不足，加上网络上对面试难度的各种“传说”，咱已经做好了“积累经验”的准备。但不到半天，HR 小姐姐就打来了电话，咱竟然顺利拿到了 offer！至今，咱的面试经验依然只有“1 次”，但这宝贵的 1 次，却像一颗小星星，点亮了职业轨迹的新方向。 实习突破：单兵作战的奇迹 在实习单位，完成了两项关键的小任务： Nacos 2.x 源码修改：独立修复了安全漏洞，趁机深入分布式配置中心的内心世界 新闻爬虫与机器人开发：从需求分析到交付上线，一个人完成了一个小项目闭环 这些经历不仅验证了技术能力，更悄悄培养了解决实际问题的工程小思维。 （单杀奇迹！单杀奇迹！！单杀奇迹！！！ヾ(≧▽≦*)o 七、技术博客：知识沉淀与分享 2025 年，咱在博客小窝里记录下技术的思考与成长的涟漪： 11 月：《读懂 DDoS 与 CC 攻击》、《OSINT 是什么？》 10 月：《深入理解 C++返回值优化(RVO)：让返回对象零成本》 9 月：《408 学习资源汇总》 8 月：《打造更专业的 GitHub 仓库：那些你不能忽略的特殊文件》 4 月：《Codeforces Round 1016 (Div. 3) 解题报告》 3 月：《lombok 与 delombok: 在 gradle 上的配置方法》、《GitHub Skills：从零到精通的 GitHub 互动学习平台》 这些文章不仅希望能帮到路过的小伙伴，更是咱梳理自己知识小宇宙的过程呢。 八、年度关键词 关键词 诠释 技术独立 从依赖他人服务到亲手搭建完整的技术小栈 开源贡献 从使用者到小小创造者 系统思维 从单一功能到整体架构，理解系统之间的悄悄话 工程实践 从理论到落地，解决真实世界的小问题 数字资产 从虚拟身份到真实掌控，建立自己的技术小品牌 九、致谢与展望 2025 年，咱要特别感谢这些默默支持的伙伴们： GitHub：提供开源协作的游乐园，让代码连接世界 雨云：提供稳定可靠的云上小家园，让想法落地生根 Cloudflare：提供全球加速和安全防护的小盾牌，让服务无界可达 站在 2026 年的起点，咱的心里装满了期待的小星星： 开源贡献：在更多项目中扮演更有爱的小维护者角色 技术品牌：通过 yuhiri.me 域名，更好地整合和分享咱的技术输出 知识体系化：建立更完善、更可爱的技术知识小仓库和分享机制 “愿此行，终抵群星！”✨ —— 2025 年的每一步，都是向着心中那片星辰大海的、坚定又可爱的小小跋涉。 注：本文数据来源于个人小记录，技术感悟来自 2025 年 365 个日夜的实践与小思考。","categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://yuhiri.me/tags/%E5%BC%80%E6%BA%90/"},{"name":"云计算","slug":"云计算","permalink":"http://yuhiri.me/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"服务器运维","slug":"服务器运维","permalink":"http://yuhiri.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"},{"name":"Python","slug":"Python","permalink":"http://yuhiri.me/tags/Python/"},{"name":"NoneBot","slug":"NoneBot","permalink":"http://yuhiri.me/tags/NoneBot/"},{"name":"职业发展","slug":"职业发展","permalink":"http://yuhiri.me/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"},{"name":"技术总结","slug":"技术总结","permalink":"http://yuhiri.me/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"}],"author":"talentestors"},{"title":"读懂DDoS与CC攻击","slug":"DDoS-and-CC","date":"2025-11-20T11:04:40.000Z","updated":"2026-01-05T13:46:19.809Z","comments":true,"path":"2025/11/20/DDoS-and-CC/","permalink":"http://yuhiri.me/2025/11/20/DDoS-and-CC/","excerpt":"","text":"DDoS 攻击与 CC 攻击 在数字世界的战场上，确保在线服务的稳定与流畅是每个运营者的核心任务。然而，总有不怀好意的攻击者试图让我们的服务陷入瘫痪。其中，DDoS 攻击和 CC 攻击是最令人头疼的两种手段。它们虽同属“拒绝服务攻击”的大家族，但攻击理念和方式却大相径庭。 1. DDoS 攻击（分布式拒绝服务攻击） 通过分布在全球的僵尸网络（Botnet）向目标服务器发送海量请求，耗尽带宽、硬件资源或协议处理能力，导致服务瘫痪。 攻击层次主要集中在网络层、传输层（如 UDP 洪水、SYN 洪水、ICMP 洪水）。 特点： 流量大：通过大量伪造 IP 发送巨量数据包，占用目标带宽。 分布式来源：攻击源分散，难以通过 IP 封禁防御。 简单粗暴：攻击逻辑简单，依赖“以量取胜”。 防御手段： 流量清洗（过滤异常流量）。 使用高防 IP 或 CDN 分散流量。 配置防火墙规则限制协议请求速率（如 SYN 请求）。 🛡️ Cloudflare 如何防御 DDoS 攻击 Cloudflare 防御 DDoS 攻击的核心，可以概括为“全局调度，边缘拦截”。 海量容量与智能调度：Cloudflare 构建了一个拥有超过 449 Tbps 网络容量的全球 Anycast 网络。当攻击流量涌来时，会被分散到全球 300 多个数据中心的边缘节点，避免单点被压垮。 多层次协同防御：Cloudflare 的防护体系覆盖网络层（L3）、传输层（L4）到应用层（L7）。 L3/L4 防御：在数据包到达服务器网卡时，内核中的 L4Drop 程序（基于 eXpress Data Path, XDP）会第一时间根据已有规则丢弃恶意包。同时，运行在每个边缘服务器上的 dosd 程序会持续分析流量样本，一旦检测到攻击，能即时生成签名并推送缓解规则。 L7 防御：对于 HTTP/HTTPS 洪水攻击，dosd 同样会分析请求样本，并通过 Web 应用防火墙（WAF）等组件对攻击请求进行封堵、速率限制或发起质询。 2. CC 攻击（Challenge Collapsar，挑战黑洞攻击） 一种应用层 DDoS 攻击，通过模拟正常用户行为（如频繁请求动态页面、API 接口），消耗服务器 CPU、数据库等资源。 攻击层次集中在应用层（如 HTTP/HTTPS） 特点： 低流量、高成本请求：单次请求可能触发复杂操作（如数据库查询），导致服务器资源过载。 高度伪装：模仿真实用户行为（如正常浏览器请求），难以被传统防火墙识别。 精准打击：针对特定高负载功能（如登录、搜索、支付接口）。 防御手段： Web 应用防火墙（WAF）识别异常请求模式。 限制单个 IP 的请求频率（如人机验证、验证码）。 优化代码逻辑，缓存高频请求结果。 🚫 Cloudflare 如何缓解 CC 攻击 C 攻击更狡猾，它模拟正常用户频繁请求动态页面（如登录、搜索），从而耗尽服务器的 CPU 和数据库资源。Cloudflare 的应对策略侧重于“行为分析，精准拦截”。 速率限制：这是防御 CC 攻击最基本有效的手段。你可以基于 IP、会话或全局维度，设置特定时间窗口内允许的请求次数，从而直接限制单个“用户”的请求频率。 质询与验证：当检测到可疑行为时，Cloudflare 可以自动发起挑战，要求访问者通过 JavaScript 计算或验证码（CAPTCHA）来证明自己是真人。恶意机器人通常无法通过此验证。 WAF 与精准规则：利用 Cloudflare 的 WAF，你可以编写自定义规则来拦截具有特定攻击特征的请求，例如异常的用户代理（User-Agent）、畸长的 Referer，或针对某个敏感 API 接口的密集访问。 基础防御配置指南 对于 Cloudflare 用户，可以采取以下几个关键步骤来激活防护： 开启“遭受攻击”模式：在域名概览的“快速操作”中，一键开启此模式。它会强制对所有访问者进行验证，有效应对正在进行的应用层攻击。 启用 Web 应用程序防火墙（WAF）：在“防火墙”应用的“托管规则”选项卡中，确保 WAF 处于开启状态。并善用其中的“速率限制规则”来防御 CC 攻击。 利用防火墙工具：根据服务器日志或 Cloudflare 分析，如果发现攻击来自特定国家、IP 段或自治系统（ASN），可以使用防火墙中的 IP 访问规则或防火墙规则进行批量封禁。 隐藏真实服务器 IP：务必确保所有指向你服务器的域名都通过 Cloudflare 代理（打开小橙云），避免攻击者绕过 Cloudflare 直接攻击你的源站。 参考资料： Cloudflare 自发边缘 DDoS 保护之剖析 分布式拒绝服务(DDoS)防护 Cloudflare Docs","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"DDoS","slug":"DDoS","permalink":"http://yuhiri.me/tags/DDoS/"},{"name":"CC攻击","slug":"CC攻击","permalink":"http://yuhiri.me/tags/CC%E6%94%BB%E5%87%BB/"},{"name":"网络安全","slug":"网络安全","permalink":"http://yuhiri.me/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"author":"talentestors"},{"title":"OSINT是什么？","slug":"What-is-OSINT","date":"2025-11-13T07:09:29.000Z","updated":"2026-01-05T13:42:58.576Z","comments":true,"path":"2025/11/13/What-is-OSINT/","permalink":"http://yuhiri.me/2025/11/13/What-is-OSINT/","excerpt":"","text":"OSINT 是什么？ 开源情报 OSINT（Open-Source Intelligence，开源情报）是一种完全基于公开信息的情报收集与分析方法。它的本质并非神秘技术，而是通过系统性挖掘、验证和整合任何人可合法获取的公开数据，转化为有价值的决策依据。以下是其核心概念的纯粹解析： 核心定义 “开源” ≠ 技术开源 此处的&quot;开源&quot;指信息来源的公开性——所有数据均来自非机密、非侵入性渠道（如新闻网站、政府公告、社交媒体、学术论文、商业登记记录等），而非技术领域的开源代码。 “情报” ≠ 间谍活动 OSINT 产出的&quot;情报&quot;是经过验证的结构化信息，用于支撑客观决策（例如企业风险评估、网络安全防护），与影视作品中的秘密行动毫无关联。 三大核心原则 合法性边界 仅使用法律允许访问的信息（如企业官网披露的财报、公开的卫星地图、已发布的专利文件）。 绝不涉及：未经授权的数据爬取、隐私信息窃取、或绕过访问限制的行为。 信息验证优先 OSINT 的核心价值不在于&quot;收集更多&quot;，而在于交叉验证真实性： 通过多源比对（如新闻报道+政府数据库+社交媒体时间线）排除虚假信息。 依赖逻辑推理与证据链构建（例如通过公开活动记录推断企业战略动向）。 目标驱动性 所有信息收集必须围绕明确需求展开： 企业场景：验证合作伙伴资质、监测竞争对手动态。 安全领域：识别组织暴露的敏感信息以加固防御。 社会调查：通过公开数据还原事件真相（如灾害影响评估）。 信息来源全景 OSINT 的数据来源远超互联网范畴，可分为两大维度： 维度 典型来源 数字公开源 搜索引擎索引内容、社交媒体动态、政府开放数据库、学术期刊、电商平台评论、开源代码仓库 非数字公开源 报纸/电视新闻、公开会议记录、商业黄页、卫星影像、专利文献、图书馆档案资料 💡 关键认知：“公开&quot;不等于&quot;易得” 深网（Deep Web）中大量合法公开信息（如政府数据库未被搜索引擎收录的部分）仍属于 OSINT 范畴，但需通过合规途径访问。 为什么需要 OSINT？ 对抗信息不对称 在数据爆炸时代，关键信息常被噪声淹没。OSINT 通过结构化方法，将碎片化公开数据转化为可行动的洞察。 降低决策风险 企业并购前核查目标公司诉讼记录、网络安全团队预判攻击面——这些决策若缺乏公开信息支撑，极易陷入盲区。 守护公共利益 记者通过卫星图像验证冲突地区动态、公民组织追踪环境污染证据，OSINT 已成为透明社会的基石工具。 不可忽视的挑战 真实性困境 公开信息可能包含错误、过时内容或刻意误导（如伪造的社交媒体账号），要求分析者具备批判性思维。 伦理灰色地带 当个人信息通过公开渠道被聚合利用时（例如通过招聘网站+社交媒体拼凑员工背景），可能触及隐私保护边界，需严格遵循当地法规（如 GDPR）。 认知负荷过载 海量数据中提炼有效信息，对分析者的逻辑建模能力提出极高要求——这也是 OSINT 区别于简单&quot;搜索&quot;的核心。 本质再思考 OSINT 的终极价值，是教会我们以系统性思维看待公开世界： “我们从未缺乏信息，缺乏的是从混沌中识别模式的能力。” 它不是技术特权，而是现代公民与从业者必备的基础素养——当你在招聘时核查候选人 LinkedIn 经历，或在投资前分析企业公开财报，你已在实践 OSINT。 在信息自由与隐私保护的平衡时代，理解 OSINT 的本质，即是理解如何负责任地驾驭公开数据的力量。 参考 美国开源情报基金会 (OSINT Foundation) Protecting biodiversity via conservation networks: Taxonomic, functional, and phylogenetic considerations https://www.iso.org/standard/75280.html","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"OSINT","slug":"OSINT","permalink":"http://yuhiri.me/tags/OSINT/"},{"name":"开源情报","slug":"开源情报","permalink":"http://yuhiri.me/tags/%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5/"},{"name":"信息分析","slug":"信息分析","permalink":"http://yuhiri.me/tags/%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90/"},{"name":"隐私伦理","slug":"隐私伦理","permalink":"http://yuhiri.me/tags/%E9%9A%90%E7%A7%81%E4%BC%A6%E7%90%86/"},{"name":"数据合规","slug":"数据合规","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E5%90%88%E8%A7%84/"}],"author":"talentestors"},{"title":"深入理解C++返回值优化(RVO)：让返回对象零成本","slug":"rvo","date":"2025-10-14T07:19:41.000Z","updated":"2026-01-05T13:44:26.746Z","comments":true,"path":"2025/10/14/rvo/","permalink":"http://yuhiri.me/2025/10/14/rvo/","excerpt":"","text":"为什么 C++函数可以安全地返回大对象而不担心性能？答案就是返回值优化。 在 C编程中，我们经常被教导要避免按值返回大对象，因为担心复制开销。但现代 C通过返回值优化(Return Value Optimization, RVO) 彻底改变了这一局面。 什么是返回值优化？ 返回值优化是 C++编译器的一项关键优化技术，它允许编译器消除函数返回时不必要的对象复制操作，直接在调用处构造返回值。 考虑这个看似&quot;危险&quot;的代码： std::vector&lt;int&gt; create_large_vector() &#123; std::vector&lt;int&gt; data(1000000); // 100万个元素 // ... 填充数据 ... return data; // 传统认知：这里会发生昂贵复制 &#125; auto result = create_large_vector(); // 但实际上可能零复制！ 没有 RVO 时，这个操作需要： 在函数内构造 data 复制 data 到临时对象 复制临时对象到 result 析构临时对象 析构函数内的 data 两次复制 + 两次析构，对于大对象简直是性能灾难！ RVO 的工作原理 基本原理 RVO 的核心思想很简单：在调用者的栈帧上直接构造返回值。 // 从程序员视角 std::vector&lt;int&gt; result = create_large_vector(); // 编译器优化后的等效代码 void create_large_vector(std::vector&lt;int&gt;* hidden_param) &#123; new (hidden_param) std::vector&lt;int&gt;(1000000); // 在指定地址直接构造 // ... 填充数据 ... // 无需返回，对象已在目标位置 &#125; std::vector&lt;int&gt; result; // 只是预留空间 create_large_vector(&amp;result); // 传递地址，直接构造 RVO 的两种形式 1. URVO (Unnamed RVO) std::vector&lt;int&gt; create_vector() &#123; return std::vector&lt;int&gt;&#123;1, 2, 3, 4, 5&#125;; // 直接返回临时对象 &#125; 2. NRVO (Named RVO) std::vector&lt;int&gt; create_vector() &#123; std::vector&lt;int&gt; result&#123;1, 2, 3, 4, 5&#125;; // 有名字的局部对象 result.push_back(6); return result; // 返回命名对象 &#125; NRVO 比 URVO 更复杂，因为它需要分析具名局部对象的生命周期，但现代编译器都能很好处理。 验证 RVO：眼见为实 让我们通过实际代码验证 RVO 的效果： #include &lt;iostream&gt; #include &lt;vector&gt; class Traceable &#123; public: Traceable() &#123; std::cout &lt;&lt; &quot;默认构造\\n&quot;; &#125; Traceable(int value) : value_(value) &#123; std::cout &lt;&lt; &quot;有参构造: &quot; &lt;&lt; value_ &lt;&lt; &quot;\\n&quot;; &#125; Traceable(const Traceable&amp; other) : value_(other.value_) &#123; std::cout &lt;&lt; &quot;复制构造: &quot; &lt;&lt; value_ &lt;&lt; &quot;\\n&quot;; &#125; Traceable(Traceable&amp;&amp; other) noexcept : value_(other.value_) &#123; std::cout &lt;&lt; &quot;移动构造: &quot; &lt;&lt; value_ &lt;&lt; &quot;\\n&quot;; other.value_ = -1; &#125; ~Traceable() &#123; std::cout &lt;&lt; &quot;析构: &quot; &lt;&lt; value_ &lt;&lt; &quot;\\n&quot;; &#125; private: int value_ = 0; &#125;; // 测试NRVO Traceable create_with_nrvo() &#123; Traceable obj(42); std::cout &lt;&lt; &quot;--- 函数内对象创建完成 ---\\n&quot;; return obj; &#125; // 测试URVO Traceable create_with_urvo() &#123; return Traceable(42); &#125; int main() &#123; std::cout &lt;&lt; &quot;=== NRVO 测试 ===\\n&quot;; auto obj1 = create_with_nrvo(); std::cout &lt;&lt; &quot;\\n=== URVO 测试 ===\\n&quot;; auto obj2 = create_with_urvo(); return 0; &#125; 开启优化时的输出(-O2): === NRVO 测试 === 有参构造: 42 --- 函数内对象创建完成 --- 析构: 42 === URVO 测试 === 有参构造: 42 析构: 42 关闭优化时的输出(-O0 -fno-elide-constructors): === NRVO 测试 === 有参构造: 42 --- 函数内对象创建完成 --- 移动构造: 42 析构: -1 移动构造: 42 析构: -1 析构: 42 === URVO 测试 === 有参构造: 42 移动构造: 42 析构: -1 析构: 42 开启优化后，所有复制和移动构造完全消失！ 什么时候会发生 RVO？ 理想情况（几乎总是优化） // 1. 直接返回临时对象 - 几乎总是优化 std::vector&lt;int&gt; case1() &#123; return std::vector&lt;int&gt;&#123;1, 2, 3&#125;; &#125; // 2. 返回局部变量（单一返回路径）- 现代编译器都能优化 std::vector&lt;int&gt; case2() &#123; std::vector&lt;int&gt; result; result.push_back(1); return result; &#125; // 3. 条件表达式中的临时对象 - 现代编译器能优化 std::vector&lt;int&gt; case3(bool flag) &#123; return flag ? std::vector&lt;int&gt;&#123;1, 2&#125; : std::vector&lt;int&gt;&#123;3, 4&#125;; &#125; C++17 的强制 RVO C++17 标准对某些情况强制要求 RVO： // C++17 强制RVO的情况： MyClass create() &#123; return MyClass(); // 返回纯右值(prvalue)，必须RVO &#125; // 但NRVO仍然是可选优化： MyClass create() &#123; MyClass obj; return obj; // 返回左值，NRVO可选 &#125; 可能阻止 RVO 的情况及解决方案 情况 1：多返回路径（不同对象） // 可能阻止NRVO std::vector&lt;int&gt; bad_example1(bool flag) &#123; std::vector&lt;int&gt; a&#123;1, 2&#125;; std::vector&lt;int&gt; b&#123;3, 4&#125;; if (flag) return a; // 返回a else return b; // 返回b - 可能阻止NRVO &#125; // 改进：单一返回路径 std::vector&lt;int&gt; good_example1(bool flag) &#123; std::vector&lt;int&gt; result; if (flag) &#123; result = &#123;1, 2&#125;; &#125; else &#123; result = &#123;3, 4&#125;; &#125; return result; // 单一返回路径，利于NRVO &#125; 情况 2：返回函数参数 // 无法RVO：参数不是局部变量 std::vector&lt;int&gt; bad_example2(std::vector&lt;int&gt; input) &#123; input.push_back(99); return input; // 无法NRVO &#125; // 改进：按引用传递，返回新对象 std::vector&lt;int&gt; good_example2(const std::vector&lt;int&gt;&amp; input) &#123; std::vector&lt;int&gt; result = input; result.push_back(99); return result; // 可以NRVO &#125; 情况 3：错误使用 std::move // 不要这样做！可能阻止RVO std::vector&lt;int&gt; wrong_way() &#123; std::vector&lt;int&gt; result; // ... 填充数据 ... return std::move(result); // 显式移动可能阻止NRVO！ &#125; // 正确做法：信任编译器 std::vector&lt;int&gt; right_way() &#123; std::vector&lt;int&gt; result; // ... 填充数据 ... return result; // 让编译器决定最优方式 &#125; RVO 与移动语义的关系 RVO 和移动语义是互补的技术： std::vector&lt;int&gt; create_vector() &#123; std::vector&lt;int&gt; local(1000); return local; // 编译器决策流程： // 1. 尝试RVO（最佳） // 2. 如果RVO失败，尝试移动构造（良好） // 3. 如果移动不可用，使用复制构造（最差） &#125; 移动语义是 RVO 的安全网：即使编译器无法进行 RVO，移动语义也能保证不错的性能。 实际性能影响 让我们看看 RVO 在不同场景下的性能提升： 小对象 vs 大对象 // 基准测试示例 struct SmallObject &#123; int data[10]; &#125;; struct LargeObject &#123; int data[10000]; &#125;; SmallObject create_small() &#123; SmallObject obj; // 初始化 return obj; &#125; LargeObject create_large() &#123; LargeObject obj; // 初始化 return obj; &#125; 典型性能结果： 小对象(几十字节)：RVO 提升 20-50% 中等对象(几 KB)：RVO 提升 2-5 倍 大对象(几 MB)：RVO 提升 10-100 倍 极大对象：避免栈溢出，RVO 至关重要 最佳实践指南 1. 编写 RVO 友好的代码 // ✅ 好的模式：单一返回路径 + 局部变量 std::vector&lt;Data&gt; process_data(const Input&amp; input) &#123; std::vector&lt;Data&gt; result; for (const auto&amp; item : input) &#123; result.push_back(process_item(item)); &#125; return result; // 让编译器优化 &#125; 2. 了解编译器能力 GCC/Clang: RVO 支持非常成熟 MSVC: 良好支持，特别是新版 ICC: 优秀的优化能力 3. 合理使用移动语义作为保障 // 当无法避免多返回路径时 std::unique_ptr&lt;BigObject&gt; create_object(Config config) &#123; if (config.type == &quot;A&quot;) &#123; return std::make_unique&lt;TypeA&gt;(); // 移动语义保证效率 &#125; else &#123; return std::make_unique&lt;TypeB&gt;(); // 移动语义保证效率 &#125; &#125; 4. 生产环境代码示例 // 工厂函数 - 充分利用RVO std::unique_ptr&lt;Connection&gt; create_connection(const Config&amp; config) &#123; auto connection = std::make_unique&lt;Connection&gt;(); // 复杂初始化逻辑 if (!connection-&gt;initialize(config)) &#123; throw std::runtime_error(&quot;初始化失败&quot;); &#125; return connection; // NRVO或移动语义 &#125; // 数据处理 - 返回大结果集 std::vector&lt;Result&gt; process_batch(const std::vector&lt;Input&gt;&amp; batch) &#123; std::vector&lt;Result&gt; results; results.reserve(batch.size()); // 预分配，避免重分配 for (const auto&amp; input : batch) &#123; results.push_back(process_single(input)); &#125; return results; // RVO确保高效返回 &#125; 调试和验证技巧 检查编译器优化 # GCC/Clang: 检查汇编输出 g++ -O2 -S -fverbose-asm test.cpp # 查看优化报告 g++ -O2 -fdump-tree-optimized test.cpp 运行时检测 // 使用自定义类型跟踪构造 class RvoDetector &#123; public: RvoDetector() &#123; std::cout &lt;&lt; &quot;构造地址: &quot; &lt;&lt; this &lt;&lt; std::endl; &#125; // ... 其他特殊成员函数 &#125;; void test_rvo() &#123; auto obj = create_rvo_detector(); std::cout &lt;&lt; &quot;最终地址: &quot; &lt;&lt; &amp;obj &lt;&lt; std::endl; // 如果地址相同，说明发生了RVO &#125; 总结 RVO 是现代 C++中最重要的优化之一，它让我们能够： 编写更清晰的代码：自然返回对象，无需复杂指针操作 获得更好的性能：消除不必要的复制操作 保持代码安全性：避免手动内存管理错误 关键要点： 信任编译器，编写自然的返回语句 保持单一返回路径帮助 NRVO C++17 对 URVO 提供标准保证 移动语义是性能的安全网 避免使用std::move返回局部对象 在现代 C++中，你应该放心地这样写： BigObject compute_complex_result() &#123; BigObject result; // ... 复杂计算 ... return result; // 清晰、安全、高效 &#125; auto data = compute_complex_result(); // 享受零成本抽象 RVO 让 C程序员能够以值语义编写清晰、安全的代码，同时享受接近手动优化的性能。这是 C&quot;零成本抽象&quot;哲学的美好体现！","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"RVO","slug":"RVO","permalink":"http://yuhiri.me/tags/RVO/"}],"author":"talentestors"},{"title":"408 学习资源汇总","slug":"408-route","date":"2025-09-28T06:04:00.000Z","updated":"2026-01-05T13:48:35.444Z","comments":true,"path":"2025/09/28/408-route/","permalink":"http://yuhiri.me/2025/09/28/408-route/","excerpt":"","text":"1. 数据结构 【【完结】【CS61B精翻双语·英文原声】伯克利大学《算法与数据结构》(2024)】 预计学时：60 小时 BV号：BV1hJ4m1M7ZA 课程资源：https://www.learncs.site/docs/curriculum-resource/cs61b 2. 计算机网络 【中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程】 预计学时：40 小时 BV号：BV1JV411t7ow 课程视频是郑烇老师本人在哔哩哔哩上上传的，视频质量很高，内容也很详细，适合初学者入门。 3. 操作系统 4. 计算机组成原理","categories":[{"name":"资源","slug":"资源","permalink":"http://yuhiri.me/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"408","slug":"408","permalink":"http://yuhiri.me/tags/408/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yuhiri.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"author":"yuhiri"},{"title":"打造更专业的 GitHub 仓库：那些你不能忽略的特殊文件","slug":"github-special-files-guide","date":"2025-08-23T08:31:10.000Z","updated":"2026-01-05T13:45:55.310Z","comments":true,"path":"2025/08/23/github-special-files-guide/","permalink":"http://yuhiri.me/2025/08/23/github-special-files-guide/","excerpt":"","text":"在开源的世界里，代码固然重要，但一个结构清晰、文档完备的 GitHub 仓库，往往才是项目能否长久发展的关键。除了我们熟知的 README 和 LICENSE，GitHub 还支持一系列具有特殊作用的文件，它们不仅是项目的“门面”，更是高效协作的“规则手册”。 今天，我想结合自己的经验，跟大家聊聊这些文件的作用和使用技巧——无论你是刚入门的新手，还是经验丰富的维护者，相信这些小细节都能帮你把项目打理得更专业。 一、为什么这些文件如此重要？ 开源项目不只是代码的集合，更是一个小型社区。清晰的文件结构能显著降低参与门槛，让更多人愿意——并且能够——有效地参与进来。在我看来，这些文件至少带来四个好处： 提升可信度：规范的文档传递出“这是一个认真项目”的信号； 减少重复问题：很多常见疑问其实可以通过文档提前解答； 自动化流程：利用 GitHub 的识别机制，让机器帮你处理琐事； 明确责任与期望：无论是行为准则还是贡献方式，写下来才算数。 二、核心文件：每一个仓库都应该有的基础 1. README.md：你的项目名片 README 通常是用户第一眼看到的内容，它必须清晰说明三件事：项目是做什么的、为什么存在、如何开始使用。我一般会遵循这些原则： 开头用一两句话概括项目核心价值； 提供至少一个完整的使用示例或代码片段； 必要时加入截图、动图或示例链接； 使用清晰的标题结构和徽标（比如构建状态、版本号等）。 支持 Markdown、RST 或纯文本格式，但 .md 是最通用的选择。 2. LICENSE：开源的法律基础 没有许可证的开源项目几乎等同于“不可使用”。GitHub 会自动在仓库顶部显示许可证类型，这对使用者非常重要——我每次用别人代码前都会先确认许可证兼容性。 如果你不知道选哪个，可以用 GitHub 提供的许可证选择器，它很贴心地列出了常见需求对应的推荐。 3. CHANGELOG.md：记录项目的成长 每次发布新版本时维护更新日志，能帮助用户快速了解变动。我喜欢用 Keep a Changelog 推荐的格式，按 Added、Changed、Fixed 等分类组织内容。 三、社区协作文件：让协作更顺畅 当用户发起 Issue 或 Pull Request 时，GitHub 会自动提示这些文件： 1. CONTRIBUTING.md：降低贡献门槛 贡献指南应明确说明： 如何设置开发环境； 代码提交或 PR 应遵循的规范； 测试要求； 如何报告 Bug 或提议新功能。 写的时候不妨站在初次参与者的角度思考：他们需要哪些信息才能顺利完成第一次贡献？ 2. CODE_OF_CONDUCT.md：构建友好的社区环境 行为准则不是摆设，而是确保所有参与者感到安全、受尊重的基础。通常采用 Contributor Covenant 这类成熟模板即可。 3. SECURITY.md：安全漏洞处理流程 说明如何报告安全漏洞、响应时间承诺等，体现项目对安全问题的重视。 4. SUPPORT.md：在哪里可以获得帮助？ 明确用户应在哪里寻求帮助（如论坛、Discord），避免维护者被重复问题淹没。 四、.github/ 目录：高级功能配置区 这个目录下的文件会被 GitHub 自动识别并应用： 1. FUNDING.yml：开启赞助渠道 可以通过它配置 GitHub Sponsors、Open Collective 等资助方式，为项目提供持续发展的动力。 2. ISSUE_TEMPLATE/ 与 PULL_REQUEST_TEMPLATE/：规范化输入 设计良好的模板可以极大提高处理效率。比如： Issue 模板可区分“Bug 报告”和“功能请求”； PR 模板可要求填写测试情况、关联的 Issue 等。 3. workflows/：自动化工作流 这里存放 GitHub Actions 的配置文件，实现 CI/CD、自动检查、部署等功能。好的自动化能节省大量人力。 五、还有一些你可能没想到的 1. GOVERNANCE.md：中大型项目的治理结构 适合团队项目，用于明确维护者职责、决策机制等。 2. CITATION.cff：方便学术引用 如果你的项目被用于研究，这个文件能提供标准引用格式。 3. docs/：用 GitHub Pages 构建项目文档 专业的文档站能极大提升用户体验，而 GitHub Pages 让它几乎零成本实现。 几个实践建议 从我踩过的坑里总结出这几条： 注意大小写：文件名必须准确，比如 README 不能写成 readme； 位置很重要：大部分文件放在根目录或 .github/ 下都行，但行为准则和安全政策建议放在根目录，更显眼； 内容＞形式：不要为了有而有，确保每份文件都有实质内容并持续更新； 从简开始：不必一次性补全所有文件，可以从 README、LICENSE 和 CONTRIBUTING 开始，逐步扩展。 写在最后 维护开源项目不仅是写代码，更是经营一个微型的生态系统。这些特殊文件就像是路标和规则，帮助每一个路过或想要留下来的人更好地理解、使用和参与。 不妨现在就打开你的仓库看看，有没有漏掉什么？哪怕只是补充一份清晰的 README，也会让项目显得更加可信、更易接近。","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://yuhiri.me/tags/%E5%BC%80%E6%BA%90/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yuhiri.me/tags/GitHub/"},{"name":"README","slug":"README","permalink":"http://yuhiri.me/tags/README/"},{"name":"LICENSE","slug":"LICENSE","permalink":"http://yuhiri.me/tags/LICENSE/"},{"name":"CONTRIBUTING","slug":"CONTRIBUTING","permalink":"http://yuhiri.me/tags/CONTRIBUTING/"},{"name":"仓库管理","slug":"仓库管理","permalink":"http://yuhiri.me/tags/%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/"}],"author":"talentestors"},{"title":"Codeforces Round 1016 (Div. 3) 解题报告","slug":"Codeforces-Round-1016-Div-3-解题报告","date":"2025-04-09T05:06:47.000Z","updated":"2026-01-05T13:46:25.931Z","comments":true,"path":"2025/04/09/Codeforces-Round-1016-Div-3-解题报告/","permalink":"http://yuhiri.me/2025/04/09/Codeforces-Round-1016-Div-3-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"","text":"比赛地址：https://codeforces.com/contest/2093 Codeforces Round 1016 (Div. 3) A. Ideal Generator https://codeforces.com/contest/2093/problem/A 题意 思路 只有奇数长度的 k 能满足条件 k=1: [1], [2], …, [n] k=2: [1, 1], x, [2, 2] k=3: [1, 1, 1], [1, 2, 1], [2, 1, 2] …… AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); inline void solve() { int k; cin &gt;&gt; k; if (k &amp; 1) { cout &lt;&lt; \"Yes\\n\"; } else { cout &lt;&lt; \"No\\n\"; } } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; } B. Expensive Number https://codeforces.com/contest/2093/problem/B 题意 思路 只保留从右往左，第一个非零的数位和它前面的 0，其它的数位都移除 AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); int cnt[110]; inline void solve() { memset(cnt, 0, sizeof(cnt)); string num; cin &gt;&gt; num; const int len = num.size(); for (int i = 1; i &lt; len; ++i) { if (num[i] == '0') cnt[i] += cnt[i - 1] + 1; else cnt[i] = cnt[i - 1]; } int idx = len - 1; for (; idx &gt;= 0; --idx) { if (num[idx] != '0') break; } cout &lt;&lt; len - 1 - cnt[idx] &lt;&lt; '\\n'; } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; } C. Simple Repetition https://codeforces.com/contest/2093/problem/C 题意 思路 当 k 大于 1，除了 x = 1 时，都是 NO x = 1，需要特判。这里直接将 y 构造出来，然后 k 变成 1 k 为 1 时，直接判断是否为质数 AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); ll x, k; bool isPrime(const ll n) { if (n == 1) return false; if (n == 2 || n == 3) return true; if (n % 2 == 0 || n % 3 == 0) return false; for (ll i = 5; i &lt;= n / i; i += 6) { if (n % i == 0 || n % (i + 2) == 0) return false; } return true; } inline void solve() { cin &gt;&gt; x &gt;&gt; k; if (x == 1) { ll a = 0; while (k--) { a *= 10; a += x; } x = a, k = 1; } if (k &gt; 1) { cout &lt;&lt; \"NO\\n\"; return; } cout &lt;&lt; (isPrime(x) ? \"YES\\n\" : \"NO\\n\"); } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; } D. Skibidi Table https://codeforces.com/contest/2093/problem/D 题意 Vadim loves filling square tables with integers. But today he came up with a way to do it for fun! Let’s take, for example, a table of size , with rows numbered from top to bottom and columns numbered from left to right. We place in the top left cell, in the bottom right, in the bottom left, and in the top right. That’s all he needs for fun! Fortunately for Vadim, he has a table of size . He plans to fill it with integers from to in ascending order. To fill such a large table, Vadim will divide it into equal square tables, filling the top left one first, then the bottom right one, followed by the bottom left one, and finally the top right one. Each smaller table will be divided into even smaller ones as he fills them until he reaches tables of size , which he will fill in the order described above. Now Vadim is eager to start filling the table, but he has questions of two types: what number will be in the cell at the -th row and -th column; in which cell coordinates will the number be located. Help answer Vadim’s questions. 思路 递归，不断缩小边界 AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); int n, q; ll d, x, y; int mpx[5] = {0, 1, 2, 2, 1}; int mpy[5] = {0, 1, 2, 1, 2}; int blocks[2][2] = { {1, 4}, {3, 2} }; void find_num(const ll m, ll i = 1, ll j = 1LL &lt;&lt; n, const ll mi = 1LL, const ll mx = 1LL &lt;&lt; (n &lt;&lt; 1)) { if (mi == mx) { x = i; y = j; return; } const ll del = (mx - mi + 1) / 4; const ll pos = m % del; const ll block = m / del + (pos != 0); const ll del2 = sqrt(del); i += mpx[block] == 2 ? del2 : 0; j -= mpy[block] == 1 ? del2 : 0; find_num(pos, i, j, mi + (block - 1) * del, mx - (4 - block) * del); } ll get_num(ll i, ll j, const ll mi = 1LL, const ll mx = 1LL &lt;&lt; (n &lt;&lt; 1)) { if (mi == mx) return mi; const ll del = (mx - mi + 1) / 4; const ll del2 = sqrt(del); const ll block = blocks[i &gt; del2][j &gt; del2]; i = i &gt; del2 ? i - del2 : i; j = j &gt; del2 ? j - del2 : j; return get_num(i, j, mi + (block - 1) * del, mx - (4 - block) * del); } inline void solve() { // 1 4 13 16 // 3 2 15 14 // 9 12 5 8 // 11 10 7 6 cin &gt;&gt; n &gt;&gt; q; string spt; while (q--) { cin &gt;&gt; spt; if (spt[0] == '-') { // q1 cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; get_num(x, y) &lt;&lt; '\\n'; } else { // q2 cin &gt;&gt; d; find_num(d); cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n'; } } } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://yuhiri.me/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"CodeForces","slug":"CodeForces","permalink":"http://yuhiri.me/tags/CodeForces/"},{"name":"Div3","slug":"Div3","permalink":"http://yuhiri.me/tags/Div3/"},{"name":"C/CPP","slug":"C-CPP","permalink":"http://yuhiri.me/tags/C-CPP/"}],"author":"talentestors"},{"title":"lombok 与 delombok: 在 gradle 上的配置方法","slug":"lombok与delombok-在gradle上的配置方法","date":"2025-03-16T07:40:32.000Z","updated":"2026-01-05T13:44:55.779Z","comments":true,"path":"2025/03/16/lombok与delombok-在gradle上的配置方法/","permalink":"http://yuhiri.me/2025/03/16/lombok%E4%B8%8Edelombok-%E5%9C%A8gradle%E4%B8%8A%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、Lombok的双刃剑效应 在Java开发领域，Lombok 凭借其强大的代码简化能力几乎无人不晓。通过 @Data、@Builder 等注解，开发者可以轻松消除冗长的 getter/setter 方法，将开发效率提升 40% 以上。但正如所有技术选型都需要权衡利弊，Lombok 在实际应用中暴露出的问题同样值得警惕： 强工具依赖困境：开发团队中只要有一位成员使用 Lombok，所有协作者都必须安装插件，否则将面临编译失败的风险 代码可追溯性缺失：生成的字节码与源码存在&quot;断层&quot;，审计时难以验证代码真实性，给金融、政务等强合规场景埋下隐患 版本兼容性陷阱：不同 Lombok 版本生成的代码可能存在差异，在持续集成环境中容易引发&quot;本地可编译，服务器失败&quot;的诡异问题 正是这些痛点，使得包括阿里、华为在内的多家头部科技企业，在《Java开发规范》中明确禁止生产环境使用 Lombok。 二、Delombok：鱼与熊掌兼得的解决方案 Project Lombok 团队提供的 Delombok 工具 恰是破解困局的关键。其核心原理是在编译阶段将 Lombok 注解转换为标准 Java 代码，既保留了开发效率，又确保了代码完整性。 三、IntelliJ全链路配置指南 3.1 开发环境配置 安装官方 Lombok 插件：JetBrains Marketplace 同步安装 Delombok 插件：Delombok Plugin 启用注解处理：Settings → Build → Compiler → Annotation Processors → Enable annotation processing 3.2 版本控制集成 在提交代码前，通过 VCS 操作菜单勾选 “Delombok code” 选项，即可自动生成合规代码。对于存量项目，可通过 Build → Delombok Project 一键转换整个代码库。 四、构建工具深度集成 4.1 Maven 配置 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.30&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 4.2 Gradle 配置 dependencies &#123; compileOnly &#x27;org.projectlombok:lombok:1.18.22&#x27; annotationProcessor &#x27;org.projectlombok:lombok:1.18.22&#x27; testCompileOnly &#x27;org.projectlombok:lombok:1.18.22&#x27; testAnnotationProcessor &#x27;org.projectlombok:lombok:1.18.22&#x27; &#125; 4.3 “io.freefair.lombok” 插件：Gradle 最佳实践 推荐使用 io.freefair.lombok 插件实现 lombok 和 delombok 的管理： plugins &#123; id &quot;io.freefair.lombok&quot; version &quot;8.13&quot; &#125; // 自动处理： // 1. 注解处理器配置 // 2. Delombok 任务注册 // 3. 测试环境支持 直接声明使用最新版本 plugins &#123; id &quot;io.freefair.lombok&quot; version &quot;lastest.release&quot; &#125; 版本兼容矩阵（2025.3 最新） 插件版本 Gradle支持 Java要求 Kotlin兼容 8.13.x 8.13 8+ 2.0.20 8.11.x 8.11 8+ 2.0.20 8.10.x 8.10 8+ 1.9.24 8.7.x 8.7 8+ 1.9.22 8.6.x 8.6 8+ 1.9.20 8.4.x 8.4 8+ 1.9.10 8.3.x 8.3 8+ 1.9.0 8.2.x 8.2 8+ 1.8.20 8.1.x 8.1 8+ 1.8.10 8.0.x 8.0 8+ 1.8.10 6.6.x 7.6 8 - 18 1.7.x 6.5.x 7.5 8 - 18 1.7.x 6.4.x 7.4 8 - 17 1.3.x - 1.6.x 6.3.x 7.3 8 - 17 1.3.x - 1.6.x 本文档示例代码已通过 Java 21、Gradle 8.13 环境验证，建议定期访问 Lombok 官网，以获取最新版本信息。","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yuhiri.me/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"http://yuhiri.me/tags/Lombok/"},{"name":"Gradle","slug":"Gradle","permalink":"http://yuhiri.me/tags/Gradle/"}],"author":"talentestors"},{"title":"GitHub Skills：从零到精通的 GitHub 互动学习平台","slug":"GitHub-Skills","date":"2025-03-15T08:35:16.000Z","updated":"2026-01-05T13:46:00.560Z","comments":true,"path":"2025/03/15/GitHub-Skills/","permalink":"http://yuhiri.me/2025/03/15/GitHub-Skills/","excerpt":"","text":"GitHub Skills：从零到精通的 GitHub 互动学习平台 在软件开发的世界中，GitHub 已成为协作开发、版本控制和开源生态的代名词。然而，对于许多开发者（尤其是新手）来说，GitHub 的功能庞大且复杂，如何快速掌握其核心技能成为一大挑战。为此，GitHub 社区推出了 GitHub Skills —— 一个专为开发者和团队设计的互动学习平台，通过游戏化、实战化的课程，帮助用户系统性地掌握 GitHub 的核心工具与高级功能。 为什么选择 GitHub Skills？ 零门槛上手：无需提前安装环境，课程直接在浏览器中完成。 分阶段学习：从“第一天”到“第一周”，逐步提升技能。 实战导向：通过真实场景的练习，边学边用。 免费开放：所有课程完全免费，覆盖从 Markdown 到 CI/CD 的全栈技能。 核心课程一览 1. 第一天入门：GitHub 基础 《GitHub 入门》 用不到一小时的时间，学习仓库创建、提交代码、分支管理等基础操作，迈出 GitHub 第一步。 《用 Markdown 高效沟通》 掌握 Markdown 语法，用简洁的格式撰写文档、Issue 和 Pull Request，提升团队协作效率。 《GitHub Pages 搭建个人站点》 将仓库转化为个人博客或项目主页，无需服务器即可展示你的作品。 2. 第一周进阶：协作与工程化 《Pull Request 代码审查》 模拟团队协作场景，学习如何高效审核代码、提出建议并合并修改。 《解决代码合并冲突》 深入理解 Git 合并冲突的成因，掌握命令行和可视化工具的解决方法。 《发布管理策略》 实践基于分支的版本发布流程，探索 Git Flow 等协作模型。 《代码空间（Codespaces）》 直接在云端配置开发环境，用 VS Code 编写、调试代码，告别本地环境配置的烦恼。 3. 与 AI 协作：GitHub Copilot 《GitHub Copilot 入门》 学习如何让 AI 助手帮你生成代码、调试错误，甚至编写测试用例，提升开发效率。 《为 Copilot 定制行业扩展》 教会 Copilot 理解你的业务术语和公司规范，打造专属的AI编程伙伴。 4. 自动化与部署：GitHub Actions 《GitHub Actions 初体验》 创建第一个自动化工作流，实现代码测试、打包和通知。 《持续集成（CI）实战》 配置自动化测试流程，确保每次提交的代码质量。 《部署到 Azure》 结合 GitHub Actions 与微软云服务，一键完成应用部署。 《开发自定义 JavaScript Action》 从零编写可复用的自动化脚本，满足个性化需求。 5. 代码安全与漏洞防护 《供应链安全加固》 识别并修复依赖项漏洞，保护项目免受第三方风险影响。 《CodeQL代码分析入门》 利用 GitHub 的语义分析引擎，自动检测代码中的安全隐患。 《敏感信息扫描》 启用 Secret Scanning 功能，防止密钥或密码意外泄露。 《安全编程小游戏》 在趣味互动中学习常见的安全漏洞（如 SQL 注入、XSS）及防御方法。 如何开始？ 访问 GitHub Skills官网，选择感兴趣的主题，点击 “Start Course” 即可进入学习界面。 社区仓库：https://github.com/skills 结语 GitHub Skills不仅是一个学习平台，更是开发者进阶的“加速器”。无论你是想成为开源贡献者、提升团队协作效率，还是探索 AI 编程的未来，这里都能为你提供清晰的路径。立即行动，让 GitHub 从工具变为你的超级生产力伙伴！ 🚀","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yuhiri.me/tags/GitHub/"},{"name":"GitHub Actions","slug":"GitHub-Actions","permalink":"http://yuhiri.me/tags/GitHub-Actions/"},{"name":"课程","slug":"课程","permalink":"http://yuhiri.me/tags/%E8%AF%BE%E7%A8%8B/"}],"author":"talentestors"},{"title":"黑名单","slug":"blacklist","date":"2025-01-01T11:04:19.000Z","updated":"2026-01-05T13:47:05.179Z","comments":true,"path":"2025/01/01/blacklist/","permalink":"http://yuhiri.me/2025/01/01/blacklist/","excerpt":"","text":"黑名单 添加一些黑名单 极狐 团结引擎 Hutool Alist LNMP.org oneinstack","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"blacklist","slug":"blacklist","permalink":"http://yuhiri.me/tags/blacklist/"}],"author":"talentestors"},{"title":"重构评论系统","slug":"重构评论系统","date":"2024-12-26T07:11:32.000Z","updated":"2026-01-05T13:47:20.784Z","comments":true,"path":"2024/12/26/重构评论系统/","permalink":"http://yuhiri.me/2024/12/26/%E9%87%8D%E6%9E%84%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"最近在重构博客主题，给主题添加一些新功能，并修复了一些bug（修不完的，绝对修不完的 🙀） 我给博客新增了 giscus 和 utteranc 两种评论系统，并将自己博客的 gitalk 更换为了 giscus。 giscus 是基于 GitHub Discussions 的评论系统，utteranc 是基于 GitHub Issues 的评论系统。 下面简单介绍这两种评论系统。 utteranc 官网地址：utteranc utteranc 是一个基于 GitHub Issues 的评论系统，它会在你的 Issues 中创建一个新的 Issue 来存储评论。 因此，可以很方便地将 gitalk 的评论迁移到 utteranc。 与 gitalk 不同的是，utteranc 不需要配置 OAuth Application，不会把 clientSecret 暴露在前端，因此更加安全。 在我重构后的博客主题中，需要在配置文件中添加如下配置： comment: utteranc # 选择utteranc评论系统 ## Utteranc utteranc: owner: talentestors repo: talentestors.github.io issueTerm: location.pathname label: &quot;💬comment&quot; theme: github-light owner 和 repo 是你的 GitHub 用户名和仓库名，issueTerm 是评论的唯一标识，label 是评论的标签，theme 是评论的主题。 giscus 官网地址：giscus giscus 是一个基于 GitHub Discussions 的评论系统，它会在你的 Discussions 中创建一个新的 Discussion 来存储评论。 giscus 同样不会把敏感信息暴露在前端。 同时，基于 Discussions，它的回复功能更加完善，可以直接回复评论。 配置方法： comment: giscus # 选择giscus评论系统 ## giscus giscus: owner: talentestors repo: talentestors.github.io repoId: R_kgDOJfPMMg category: Announcements categoryId: DIC_kwDOJfPMMs4ClgjC mapping: pathname reactions: 1 metadata: 0 theme: light_tritanopia position: top lang: zh-CN api: https://giscus.app/client.js # 可以自建giscus owner 和 repo 是你的 GitHub 用户名和仓库名，repoId 和 categoryId 是 Discussions 的 ID，mapping 是评论的唯一标识。 提示： 可以从官网获取 Repo 和 Category 的 ID。 其他配置项也可以在官网查看。 关于 gitalk 的安全问题 参考这个issue，虽然 gitalk 的作者认为 clientSecret 即使是暴露在前端也不会有安全问题。 但是，我认为即使 gitalk 不会出问题，不代表 GitHub 不会出问题。把 clientSecret 暴露在前端，总归是不太合理。 因此，我还是选择了更加安全的 utteranc 和 giscus。","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Comment","slug":"Comment","permalink":"http://yuhiri.me/tags/Comment/"},{"name":"giscus","slug":"giscus","permalink":"http://yuhiri.me/tags/giscus/"},{"name":"gitalk","slug":"gitalk","permalink":"http://yuhiri.me/tags/gitalk/"},{"name":"utteranc","slug":"utteranc","permalink":"http://yuhiri.me/tags/utteranc/"}],"author":"talentestors"},{"title":"那些算法在哪里？","slug":"Where-are-those-algorithms","date":"2024-12-17T15:21:57.000Z","updated":"2026-01-05T13:42:37.027Z","comments":true,"path":"2024/12/17/Where-are-those-algorithms/","permalink":"http://yuhiri.me/2024/12/17/Where-are-those-algorithms/","excerpt":"","text":"文章源：Linux 中国 归档仓库：https://github.com/Linux-CN/archive 归档文章源码 linux.cn: 那些算法在哪里？ 归档站点：https://archive.linux.cn/ 本文来源于一篇stackexchange的问题回答。提问者问到，我们在计算机科学和数学课程里面学习到的那些算法，到底在什么地方用到了？结果Vijay D给出一个洋洋洒洒的深入回答，得到了提问者和众多围观。我们将这篇回答翻译过来以飨读者。 Vijay D写到： 在我看来，一个系统背后主要发挥作用的算法更容易在非算法课程上找到，这和应用数学中的成果比理论数学中更容易出现在应用中是一个道理。在讲座中，很少有实际问题能够精确匹配到一个抽象问题。归根结底，我认为没有理由让流行的算法课程，诸如Strassen乘法，AKS素性测试、或者Moser-Tardos算法与底层实际问题，如实现视频数据库、优化的编译器、操作系统、网络拥堵控制系统或者其他系统相关。这些课程的价值是学习利用错综复杂的方法发现问题的脉络而找出有效的解决方案。高级算法和简单算法的分析都不简单。正是由于这个原因，我不会忽略简单随机算法或者PageRank。 我想你可以选择任何一个大型软件，并在内部找到它所采用的基础和高级的算法。作为一个研究案例，我选择了Linux内核，并会示例一些Chromium里面的例子。 Linux内核中的基本数据结构和算法 Linux内核(源代码的链接在github)。 1.链表、双向链表、无锁链表。 2.B+ 树，这是一些你无法在教科书上找到的说明。 一个相对简单的B+树的实现。我把它作为一个学习练习来帮助理解B+树是如何工作的。这同样也被证明是有用的。 … 一个在教科书中并不常见的技巧。最小的值在右侧而不是在左侧。所有在一个节点里用到的槽都在左侧，所有没有用到的槽包含了空值(NUL)。大多数操作只简单地遍历所有的槽一次并在第一个空值时(NUL)终止。 3.优先排序列表 用于 互斥量、驱动等等。 4.红黑树用于调度、虚拟内存管理、追踪文件描述符和目录项等。 5.区间树 6.根树用于内存管理，NFS相关查询和网络相关功能。 根树的一个通用的用处是存储指针到结构页中。 7.优先级堆，如其名称的教科书实现，用于cgroup。 《简单的基于CLR的只插入的，含有指针的定长优先级堆》第七章 8.哈希函数，参考了Knuth和一篇论文。 Knuth建议，用乘法哈希的机器字来表示接近黄金比例的素数的最大整数。Chuck Lever验证了该技术的有效性： http://www.citi.umich.edu/techreports/reports/citi-tr-00-1.pdf 这些素数的选择是位稀疏的，他们可以通过移位和加法操作，而不必使用乘法器，乘法器是很慢的。 9.有的代码，比如这个驱动，实现了他们自己的哈希函数。 使用了一种旋转哈希算法的哈希函数 Knuth, D. 《计算机程序设计艺术, 卷 3: 排序与搜索》, 第6、7章. Addison Wesley, 1973 10.哈希表用于实现inode、文件系统完整性检测等等。 11.位数组用于处理标志位、中断等等。并在Knuth那本书的卷4中阐述。 12.信号量和自旋锁 13.二分查找用于中断处理,寄存器缓存查询等等。 14.B树的二分查找。 15.深度优先搜索被广泛地用于目录配置中。 执行一个修改过的命名空间树的深度优先遍历，以指定的start_handle节点开始（及结束）。回调函数会在任何一个参数匹配的节点被发现时被调用。如果回调函数返回了一个非0值，搜索将会立即终止并且将其返回给调用者。 16.广度优先搜索用于检测运行时锁定的正确性。 17.链表中的归并排序用于垃圾收集、文件系统管理等等。 18.冒泡排序在一个驱动库中也有一个令人惊讶的实现。 19.Knuth-Morris-Pratt 字符串匹配, 根据Knuth、Morris和Pratt[1]实现了一个线性时间的字符串匹配算法。他们的算法避免了转换函数的显式地计算DELTA。对于长度为n的文本，其匹配时间是O(n)，对于长度为m的模式(pattern)，仅使用一个辅助函数PI[1 . .m]，预先计算模式的时间为O(m)。数组PI允许转换函数DELTA被实时有效地计算。粗略地说，对于任何状态&quot;q&quot;= 0,1,…、m和在SIGMA中的任何字符&quot;a&quot;,PI[“q”]的值包含的信息是独立的&quot;a&quot;并需要计算DELTA(“q”,“a”) [2]。既然PI只有m个记录，而DELTA有O(m |SIGMA|)个记录，在预处理时间计算PI而不是DELTA的时候，我们可以节省一个因数|SIGMA| [1] Cormen, Leiserson, Rivest, Stein，算法介绍，第二版，MIT出版社 [2] 见有限自动机原理 20.Boyer-Moore 模式匹配是在找替代品时的参考和建议。 实现了Boyer-Moore字符串匹配算法: [1] 《一个快速的字符串搜索算法》，R.S. Boyer and Moore.计算机通信协会，20(10), 1977, pp. 762-772. http://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf [2] 《准确的字符串匹配算法手册》，Thierry Lecroq, 2004 http://www-igm.univ-mlv.fr/~lecroq/string/string.pdf 注:由于Boyer-Moore(BM)从右到左搜索匹配，仍然有可能匹配分布在多个块，在这种情况下该算法并没有优势。 如果你希望确保这样的事情永远不会发生，那使用Knuth-Pratt-Morris(KMP)实现。总之，根据您的设置适当地选择字符串搜索算法。 如果你正在用文本搜索器进行过滤，NIDS或任何类似的注重安全的目的，那么使用KMP。否则，如果你真的关心性能，并且你对数据包进行分类以使用服务质量(QoS)政策，当你不介意匹配可能分布分散，那么用BM。 Chromium 浏览器中的数据结构和算法 Chromium的(源代码在 Google code)。我只会列出一部分。我建议使用搜索来找到你最喜欢的算法或者数据结构。 1.伸展树。 这个树通过分配策略（分配器）参数化。这个策略用于C的可用存储区的列表分配，参见zone.h。 2.Voronoi算法用于一个示例。 3.基于Bresenham算法的选项卡 在Chromium的第三方代码里面也有如下的数据结构和算法。 1.二叉树 2.红黑树 Julian Walker的总结 红黑树是一个有趣的小东西。他们被认为比AVL树(它们的直接竞争对手)简单，乍一看这似乎是由于插入是一项轻松的乐事。然而，当你开始删除时，红黑树变得非常棘手。然而，通过复杂性的平衡，插入和删除可以使用单通道，实现自上而下的算法。这与AVL树情况不一样，插入只能自顶向下，删除则需要自下而上。 … 红黑树是很流行的，像大多数数据结构一样有一个古怪的名字。比如，在Java和c++库映射结构通常用红黑树实现。红黑树的速度也与AVL树相当。而AVL树平衡性不是很好，需要保持平衡的话红黑树通常更好。有一些流传的误解，但在大多数情况下对红黑树的宣传是准确的。 3.AVL 树 4.Rabin-Karp字符串匹配用于比较。 5.自动机后缀的计算。 6.由Apple公司实现的bloom过滤器。 7.Bresenham 算法。 编程语言库 我想这个问题值得思考。编程语言设计者们认为值得花一些工程师的时间和精力来实现这些数据结构和算法，这样其他人就不必这么做了。这些库是我们在JAVA里面比C更少的发现需要重新实现基本数据结构的部分原因。 1.C++ STL包含了链表、栈、队列、映射、向量和排序、搜索和堆操作算法。 2.Java API易于扩展的并且越来越多。 3.Boost C++ 库包含了像 Boyer-Moore以及Knuth-Morris-Pratt字符串匹配算法。 分配和调度算法 我发现这些很有趣，因为即使他们被称为启发式，您使用的策略规定了算法类型和需要的数据结构，因此，所以需要人们知道栈和队列。 1.最近最少使用（LRU）算法可以用不同的方法实现。Linux内核有一种基于列表的实现。 2.其他的还有先入先出（FIFO）、最常使用和轮询。 3.FIFO的一个变种用于VAX/VMS系统。 4.Richard Carr的时钟算法用于Linux中的页面替换。 5.Intel i860处理器是一种随机替代策略。 6.自适应置换高速缓存用于一些IBM存储控制器中，也曾经用于PostgreSQL中(虽然仅仅因为一些专利问题）。 7.Knuth在《计算机程序设计艺术 卷1》中讨论过的Buddy内存分配算法内用于Linux内核中，jemalloc并发分配器被用于FreeBSD和facebook中。 *nix系统核心工具 1.grep和awk同时从正则表达式中实现NFA的Thompson-McNaughton-Yamada构造，显然这甚至击败了Perl的实现。 2.tsort实现了拓扑排序。 3.fgrep实现了Aho-Corasick字符串匹配算法。 4.GNU grep，根据作者Mike Haertel实现了Boyer-Mooresuan算法。 5.Unix上的crypt(1)实现了一个在Enigma机器上的不同加密算法。 6.Unix diff由Doug McIllroy实现，基于和James Hunt合作编写的原形。它比用于计算Levenshtein距离的标准动态规划算法执行地更好。Linux 版本计算最短编辑距离。 加密算法 这本是一个非常长的列表。加密算法在所有执行安全通信和交易的程序中都有实现。 1.Merkle 树，特别是 Tiger Tree Hash变种，被用于点对点应用，比如GTK Gnutella和LimeWire。 2.MD5被用于提供软件包的校验和并被用于在*nix系统上的完整性检测(Linux 实现)，同样也支持Windows和OSX。 3.OpenSSL实现了很多加密算法包括AES、Blowfish、DES、SHA-1、SHA-2、RSA、DES等等。 编译器 1.LALR 解析在yacc和bison实现。 2.支配算法被用于大多数基于SSA形式的编译器优化。 3.lex和flex将正则表达式编译为NFA。 压缩和图像处理 1.用于GIF图片格式的Lempel-Ziv算法在图像处理程序中实现，从*unix工具转化到复杂的程序。 2.行程长度编码用于产生PCX文件(用于原来的画笔程序)，它是被压缩的BMP和TIFF文件。 3.小波压缩是JPEG2000的基础，所以所有生成JPEG2000文件的数码相机会支持这个算法。 4.Reed-Solomon纠错在Linux内核、CD驱动器、条形码读取器、结合从Voyager中的卷积图像传输中实现。 冲突驱动语句学习算法 (CDCL) 自2000年以来，SAT求解器在工业标准的运行时间(通常是硬件工业，虽然其他地方也被使用)以近乎指数的方式每年下跌。这发展中很重要的一部分是冲突驱动语句学习算法，它结合了Davis Logemann和Loveland在约束规划和人工智能研究中关于语句学习的原始论文中的布尔约束传播算法。特定地，工业造型，SAT被认为是一个简单的问题(见这个讨论)。对我而言，这个一个最近最好的成功故事，因为它结合了这几年算法的不断发展、清晰的工程理念、实验性的评估、齐心协力地解决一个问题。Malik 和 Zhang的CACM文章值得阅读。这个算法在许多大学中教授(我参加过的4个地方都是如此)，但是通常在一个逻辑或者形式方法课上。 SAT求解器的应用有很多。IBM，Intel和许多其他公司都有他们的SAT求解器实现。OpenSuse的包管理器同样使用了一个SAT求解器。 via: http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773 译者：geekpi 校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","categories":[{"name":"转载","slug":"转载","permalink":"http://yuhiri.me/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"应用","slug":"应用","permalink":"http://yuhiri.me/tags/%E5%BA%94%E7%94%A8/"}],"author":"yuhiri"},{"title":"Codeforces Round 992 (Div. 2) 解题报告","slug":"Codeforces-Round-992-Div-2-解题报告","date":"2024-12-09T06:30:49.000Z","updated":"2026-01-05T13:46:33.897Z","comments":true,"path":"2024/12/09/Codeforces-Round-992-Div-2-解题报告/","permalink":"http://yuhiri.me/2024/12/09/Codeforces-Round-992-Div-2-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","excerpt":"","text":"比赛地址: https://codeforces.com/contest/2040 A. Game of Division 题目 https://codeforces.com/contest/2040/problem/A 题意 给你一个长度为 的整数数组 和一个整数数组 。 两个玩家正在玩一个游戏。第一个玩家选择一个索引 。然后第二个玩家选择不同的索引 。如果 不能被 整除，则第一个玩家获胜。否则，第二位棋手获胜。 我们扮演第一个玩家。确定是否可能获胜，如果可能，应该选择哪个索引 。 数字 的绝对值用 表示，如果是 ，则等于 ，否则等于 。 思路 模拟 AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); int nums[101], k; int n; int st[101]; inline void solve() { cin &gt;&gt; n &gt;&gt; k; memset(st, 0, sizeof(int) * (k + 1)); for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; nums[i]; } for (int i = 1; i &lt;= n; ++i) { bool flag = true; for (int j = 1; j &lt;= n &amp;&amp; flag; ++j) { if (i == j) continue; if (abs(nums[i] - nums[j]) % k == 0) flag = false; } if (flag) { cout &lt;&lt; \"YES\\n\" &lt;&lt; i &lt;&lt; \"\\n\"; return; } } cout &lt;&lt; \"NO\\n\"; } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; } B. Paint a Strip 题目 https://codeforces.com/contest/2040/problem/B 题意 您有一个长度为 的零数组 。 你可以对它进行两种操作： 在 和 之间选择一个索引 ，并将 赋值给 ； 选择一对索引 和 ，使得 ， ， ， ，并将所有 的 赋值给 。 要使数组中的所有元素都等于 1，至少需要进行多少次第一种类型的运算？ 思路 第 次第一种类型的运算，可覆盖的最大范围为第 次的范围加1，再乘2。 先初始化每一个i的范围，再二分查找。 AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); int n; constexpr int N = 20; ll st[N]; static const auto init= []() { st[1] = 1; for (int i = 2; i &lt; N; ++i) { st[i] = (st[i - 1] + 1) &lt;&lt; 1; } return 0; }(); inline void solve() { cin &gt;&gt; n; int p = lower_bound(st + 1, st + N, n) - st - 1; while (st[p] &lt; n) ++p; cout &lt;&lt; p &lt;&lt; '\\n'; } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; } C. Ordered Permutations 题目 https://codeforces.com/contest/2040/problem/C time limit per test: 2 seconds memory limit per test: 256 megabytes input: standard input output: standard output Consider a permutation of integers from to . We can introduce the following sum for it: Let us consider all permutations of length with the maximum possible value of . Output the -th of them in lexicographicalorder, or report that there are less than of them. A permutation of length is an array consisting of distinct integers from to in arbitrary order. For example, is a permutation, but is not a permutation ( appears twice in the array), and is also not a permutation ( but there is in the array). For example: For the permutation the value of is equal to For the permutation the value of is equal to . An array is lexicographically smaller than an array if and only if one of the following holds: is a prefix of , but ; or in the first position where and differ, the array has a smaller element than the corresponding element in . Input Each test contains multiple test cases. The first line contains the number of test cases (). The description of the test cases follows. The only line of each test case contains two integers and (; ) — the length of the permutation and the index number of the desired permutation. It is guaranteed that the sum of over all test cases does not exceed . Output For each test case, if there are less than suitable permutations, print . Otherwise, print the -th suitable permutation. Example 点击查看测试样例 Input 6 3 2 3 3 4 11 4 6 6 39 7 34 Output 1 3 2 2 3 1 -1 2 4 3 1 -1 2 3 4 5 7 6 1 Note Let us calculate the required sum for all permutations of length (ordered lexicographically): Permutation Value of In the first test case, you have to print the second suitable permutation of length . Looking at the table, we see that it is the permutation . In the second test case, you have to print the third suitable permutation of length . Looking at the table, we see that it is the permutation . 题意 考虑从 到 的整数 的排列。从 到 的整数的排列组合 。我们可以为它引入下面的和 ： 让我们考虑所有长度为 的排列，其最大可能值为 。按词典 顺序输出其中的第 个，或者报告它们的数量少于 。 长度为 的排列是由 个不同的整数组成的数组，这些整数从 到 按任意顺序排列。例如， 是一个排列，但 不是一个排列（ 在数组中出现了两次）， 也不是一个排列（ ，但数组中有 ）。 例如 对于 这个排列， 的值等于 。 对于排列 来说， 的值等于 。 . 当且仅当以下条件之一成立时，数组 的lexicographically小于数组 ： 是 的前缀，但是 ；或者 在 和 不同的第一个位置，数组 中的元素小于 中的相应元素。 输入 每个测试包含多个测试用例。第一行包含测试用例的数量 ( )。测试用例说明如下。 每个测试用例的唯一一行包含两个整数 和 （ ；{47522742}）。( ; ) - 排列的长度和所需排列的索引号。 保证所有测试用例中 的总和不超过 。 输出 对于每个测试用例，如果合适的排列组合少于 ，则打印 。 否则，打印 个合适的排列。 备注 让我们计算所有长度为 （按词典顺序排列）的排列所需的和： Permutation 的值 在第一个测试用例中，您必须打印长度为 的第二个合适的排列。观察表格，我们会发现是长度为 的排列。 在第二个测试用例中，您必须打印长度为 的第三个合适的排列。观察表格，我们会发现是长度为 的排列。 思路 通过打表，可以观察到。值为最大的 排列的数量为 。 所以只要值为最大的 排列的数量不超过 则有解，否则输出 -1 这里给出 为 5 的情况： 1: 1 2 3 4 5 = 35 2: 1 2 3 5 4 = 35 3: 1 2 4 5 3 = 35 4: 1 2 5 4 3 = 35 5: 1 3 4 5 2 = 35 6: 1 3 5 4 2 = 35 7: 1 4 5 3 2 = 35 8: 1 5 4 3 2 = 35 9: 2 3 4 5 1 = 35 10: 2 3 5 4 1 = 35 11: 2 4 5 3 1 = 35 12: 2 5 4 3 1 = 35 13: 3 4 5 2 1 = 35 14: 3 5 4 2 1 = 35 15: 4 5 3 2 1 = 35 16: 5 4 3 2 1 = 35 假设 取 7：0b0111 会发现 7 是从 3：0b0011 的后 3 位，往前挪动 1 位形成的。 而 3 是从 1：0b0001 的后两位，往前挪动 1 位形成的。 同样的 4：0b0100 是以同样的方式从 2:0b0010 转移过来的。 得出结论：第 个排列是第 prev_k（把 移除二进制的最高位，如果二进制bit 1的个数为1则左移1位）个排列的后 m（k 二进制的最左边1的位置） 位往前挪动1位形成的。 AC代码 点击查看代码 #define _USE_MATH_DEFINES // To use the definition of cmath #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; using ull = unsigned long long; // mp.reserve(1024), mp.max_load_factor(0.75); // Used only for basic types, pair and tuple. template&lt;typename T&gt; struct custom_hash_base { size_t operator()(const T&amp; x) const { static const size_t seed = chrono::steady_clock::now().time_since_epoch().count(); return _Hash_bytes(&amp;x, sizeof(x), seed); } }; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); #ifndef ONLINE_JUDGE freopen(\"../in.txt\", \"r\", stdin); #endif return nullptr; }(); ll n, k; inline ll get_next(ll x) { --x; x |= x &gt;&gt; 1; x |= x &gt;&gt; 2; x |= x &gt;&gt; 4; x |= x &gt;&gt; 8; x |= x &gt;&gt; 16; x |= x &gt;&gt; 32; ++x; return x; } inline void dfs(ll ck, vector&lt;ll&gt;&amp; v) { if (ck &lt;= 1) return; if (__builtin_popcountll(ck) == 1) dfs(ck &gt;&gt; 1, v); else dfs(ck - (get_next(ck) &gt;&gt; 1), v); ck = get_next(ck); int i = 64 - __builtin_clzll(ck) - 1; ll x = v[i]; v.erase(v.begin() + i); v.insert(v.begin(), x); } inline void solve() { cin &gt;&gt; n &gt;&gt; k; const int ci = 64 - __builtin_clzll(get_next(k)); if (n &lt; ci) { cout &lt;&lt; -1 &lt;&lt; '\\n'; return; } vector&lt;ll&gt; v(n); iota(v.rbegin(), v.rend(), 1LL); dfs(k, v); ranges::reverse(v); ranges::copy(v, ostream_iterator&lt;ll&gt;(cout, \" \")); cout &lt;&lt; '\\n'; } int main() { int T; for (cin &gt;&gt; T; T &gt; 0; --T) { solve(); } return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://yuhiri.me/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"CodeForces","slug":"CodeForces","permalink":"http://yuhiri.me/tags/CodeForces/"},{"name":"C/CPP","slug":"C-CPP","permalink":"http://yuhiri.me/tags/C-CPP/"},{"name":"Div2","slug":"Div2","permalink":"http://yuhiri.me/tags/Div2/"}],"author":"yuhiri"},{"title":"JDK 18 及以上使用标准输出流中文输出乱码问题","slug":"JDK-18-以上使用标准输出流中文输出乱码问题","date":"2024-12-05T07:43:24.000Z","updated":"2026-01-05T13:45:03.440Z","comments":true,"path":"2024/12/05/JDK-18-以上使用标准输出流中文输出乱码问题/","permalink":"http://yuhiri.me/2024/12/05/JDK-18-%E4%BB%A5%E4%B8%8A%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%E4%B8%AD%E6%96%87%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述 起因是 tomcat 调用servlet输出的System.out.println(也就是所说的控制台输出流)中文乱码，但是其他输出没有受到影响。 问题分析 运行环境：JDK 21, Tomcat 10 我所有的代码都是UTF-8编码的，而且在IDEA中设置了UTF-8编码。 并且Tomcat也配置了-Dfile.encoding=UTF-8选项 通过查看System.out的编码方式，发现是GBK，但是在控制台的编码方式是UTF-8。 System.out.println(System.out.charset()); // System.out.charset()方法自jdk18起 // output: GBK 使用jdk17的时候没有问题，但是使用jdk21就会出现乱码问题。 解决方案 参考JEP 400: UTF-8 by Default (openjdk.org)通过调用getProperty方法获取默认字符集 System.out.println(&quot;Java Runtime version &quot; + System.getProperty(&quot;java.runtime.version&quot;)); System.out.println(&quot;----------------------------------------------------------&quot;); //全局默认编码 JDK21是UTF System.out.println(&quot;Charset.defaultCharset() = &quot; + Charset.defaultCharset()); //默认文件的编码，这个应该是字节码文件 System.out.println(&quot;System.getProperty(\\&quot;file.encoding\\&quot;) = &quot; + Charset.defaultCharset().displayName()); //获取的是本地的字符集编码，中文windows系统应该是GBK System.out.println(&quot;System.getProperty(\\&quot;native.encoding\\&quot;) = &quot; + System.getProperty(&quot;native.encoding&quot;)); System.out.println(&quot;System.getProperty(\\&quot;sun.jnu.encoding\\&quot;) = &quot; + System.getProperty(&quot;sun.jnu.encoding&quot;)); //这个是输出流的默认字符集编码 System.out.println(&quot;System.getProperty(\\&quot;sun.stdout.encoding\\&quot;) = &quot; + System.getProperty(&quot;sun.stdout.encoding&quot;)); //这个是错误流的默认编码 System.out.println(&quot;System.getProperty(\\&quot;sun.stderr.encoding\\&quot;) = &quot; + System.getProperty(&quot;sun.stderr.encoding&quot;)); //console默认编码 System.out.println(&quot;System.console().charset() = &quot; + System.console().charset()); //当前输出流的编码 System.out.println(&quot;System.out.charset() = &quot; + System.out.charset()); System.out.println(&quot;----------------------------------------------------------&quot;); 在一般的情况下System.getProperty(&quot;sun.stdout.encoding&quot;)和System.getProperty(&quot;sun.stderr.encoding&quot;)的值是UTF-8，但是在Tomcat中是null。 tomcat 10 不会指定输出流的字符编码 所以我们需要在启动tomcat的时候指定输出流的字符编码 是在启动配置中的 VM options 添加参数： -Dstdout.encoding=UTF-8 -Dstderr.encoding=UTF-8 这种方法只能解决所设置程序的编码问题，若需解决 Javadoc 的乱码，则需在-D前添加-J。 -J-Dstdout.encoding=UTF-8 -J-Dstderr.encoding=UTF-8 总结 乱码问题只出现在jdk18及以上的版本，因为Java 18 中将默认编码改为了 UTF-8，但没有改动System.out和System.err的编码。 所以使用jdk17没有问题，但是在使用jdk21就会出现乱码问题。 只要在 VM options 中添加 -Dstdout.encoding=UTF-8 -Dstderr.encoding=UTF-8 即可设置输出流的编码。 参考 JEP 400: UTF-8 by Default (openjdk.org) https://openjdk.java.net/jeps/400 解决 Java 18 以上 IDEA 中文输出乱码问题（知乎） 解决IDEA控制台中输出中文乱码并探究原因(JDK18及以上)","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yuhiri.me/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"http://yuhiri.me/tags/JDK/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yuhiri.me/tags/Tomcat/"},{"name":"乱码","slug":"乱码","permalink":"http://yuhiri.me/tags/%E4%B9%B1%E7%A0%81/"}],"author":"yuhiri"},{"title":"在 Java 中设置输出流的字符集","slug":"在-Java-中设置输出流的字符集","date":"2024-11-28T11:26:29.000Z","updated":"2026-01-05T13:47:24.475Z","comments":true,"path":"2024/11/28/在-Java-中设置输出流的字符集/","permalink":"http://yuhiri.me/2024/11/28/%E5%9C%A8-Java-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86/","excerpt":"","text":"在 Java 开发中，处理字符集是一个常见的需求，尤其是在涉及到输入输出操作时。本文将通过一个简单的示例，展示如何使用 System.setOut 方法来设置标准输出流的字符集，并验证其效果。 示例代码 我们来看以下代码片段： import java.io.PrintStream; import java.nio.charset.StandardCharsets; public class CharsetExample &#123; public static void main(String[] args) &#123; // 设置标准输出流的字符集为 UTF-8 System.setOut(new PrintStream(System.out, true, StandardCharsets.UTF_8)); // 打印当前输出流的字符集 System.out.println(System.out.charset()); &#125; &#125; 代码解析 导入必要的类： 我们需要导入 PrintStream 和 StandardCharsets 类，以便能够创建新的输出流并指定字符集。 设置输出流： System.setOut(new PrintStream(System.out, true, StandardCharsets.UTF_8)); 这一行代码的作用是将标准输出流（System.out）重新设置为一个新的 PrintStream 实例。这个实例使用了 UTF-8 编码，这是一种广泛使用的字符编码方式，能够支持多种语言和符号。 打印字符集： System.out.println(System.out.charset()); 这一行代码用于打印当前输出流的字符集。通过这种方式，我们可以确认我们的设置是否成功。(注意：System.out.charset() 是jdk 18 中新增的方法) System.setOut() 用在static代码块中，可以确保在程序运行时第一时间设置输出流的字符集，同时只执行一次。 输出结果 当你运行上述代码时，控制台将输出当前设置的字符集，例如： UTF-8 这表明我们的标准输出流现在已经成功地设置为 UTF-8 编码。 为什么选择 UTF-8？ UTF-8 是一种变长编码，可以表示 Unicode 字符集中的所有字符。它能够兼容 ASCII，并且在网络传输和文件存储中具有良好的通用性。因此，在处理多语言文本或需要支持特殊符号的应用程序时，使用 UTF-8 是一个明智的选择。 总结 在 Java 中，通过 System.setOut 方法设置标准输出流的字符集，可以确保你的应用程序在处理文本输出时不会遇到编码问题。这个简单的示例展示了如何实现这一点，以及如何验证设置是否成功。通过使用 UTF-8 编码，你可以更好地支持多语言环境和各种字符。 希望这篇博客能帮助你理解如何在 Java 中有效地管理输出流的字符集！如果你有任何问题或进一步的讨论，请随时留言。","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yuhiri.me/tags/Java/"},{"name":"编码","slug":"编码","permalink":"http://yuhiri.me/tags/%E7%BC%96%E7%A0%81/"},{"name":"字符集","slug":"字符集","permalink":"http://yuhiri.me/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"输出流","slug":"输出流","permalink":"http://yuhiri.me/tags/%E8%BE%93%E5%87%BA%E6%B5%81/"},{"name":"UTF-8","slug":"UTF-8","permalink":"http://yuhiri.me/tags/UTF-8/"},{"name":"PrintStream","slug":"PrintStream","permalink":"http://yuhiri.me/tags/PrintStream/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yuhiri.me/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}],"author":"yuhiri"},{"title":"常用STL算法库汇总","slug":"常用STL算法库","date":"2024-10-11T02:16:11.000Z","updated":"2026-01-05T13:48:23.716Z","comments":true,"path":"2024/10/11/常用STL算法库/","permalink":"http://yuhiri.me/2024/10/11/%E5%B8%B8%E7%94%A8STL%E7%AE%97%E6%B3%95%E5%BA%93/","excerpt":"","text":"shuffle 洗牌算法 重排序给定范围 [first, last] 中的元素，使得这些元素的每个排列拥有相等的出现概率。 shuffle shuffle 原型 template&lt; class RandomIt, class URBG &gt; void shuffle( RandomIt first, RandomIt last, URBG&amp;&amp; g ); shuffle 使用 #include &lt;random&gt; // random_device, mt19937 #include &lt;algorithm&gt; // shuffle std::shuffle(ps.begin(), ps.end(), std::random_device()); std::random_device rd; std::mt19937 g(rd()); std::shuffle(v.begin(), v.end(), g); random_shuffle C14 中弃用，C17 中移除 random_shuffle 原型 template&lt; class RandomIt &gt; void random_shuffle( RandomIt first, RandomIt last ); template&lt; class RandomIt, class RandomFunc &gt; void random_shuffle( RandomIt first, RandomIt last, RandomFunc&amp;&amp; r ); random_shuffle 使用 std::random_shuffle(ps.begin(), ps.end()); std::random_shuffle(v.begin(), v.end(), std::mt19937()); itoa 整数转字符串 将整数转换为字符串。 （1）【头文件】#include &lt;cstdlib&gt; （2）【函数原型】char *itoa(int value, char *string, int radix); （3）【参数说明】 value：要转换的数据。 string：目标字符串的地址。 radix：转换后的进制数，可以是10进制、16进制等，范围必须在 2-36。 #include &lt;iostream&gt; #include &lt;cstdlib&gt; using namespace std; int main()&#123; int num = 100; char str[25]; itoa(num, str, 10); cout &lt;&lt; str; //输出100 return 0; &#125; itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，需要用sprintf。C标准库中有sprintf，功能比这个更强，用法跟printf类似： char str[255]; sprintf(str, &quot;%x&quot;, 100); //将100转为16进制表示的字符串。 atoi 字符串转整数 将字符串转换为整数。 https://zh.cppreference.com/w/cpp/string/byte/atoi （1）【头文件】#include &lt;stdlib.h&gt; （2）【函数原型】int atoi (const char * str); （3）【函数说明】atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等），直到遇上数字或正负符号才开始做转换，而再遇到 非数字 或 字符串结束时(’\\0’) 才结束转换，并将结果返回。函数返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。 #include &lt;iostream&gt; #include &lt;cstdlib&gt; using namespace std; int main()&#123; const char *s = &quot; 134&quot;; int num = atoi(s); cout &lt;&lt; num; //输出：134 return 0; &#125; strstr() 字符串查找 在字符串中查找子串。 C 库函数 char *strstr(const char *haystack, const char *needle) 在字符串 haystack 中查找第一次出现字符串 needle 的位置，不包含终止符 ‘\\0’。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; const char haystack[20] = &quot;RUNOOB&quot;; const char needle[10] = &quot;NOOB&quot;; char *ret; ret = strstr(haystack, needle); printf(&quot;子字符串是： %s\\n&quot;, ret); return(0); &#125; strncmp() 字符串字典序比较 str1 – 要进行比较的第一个字符串。 str2 – 要进行比较的第二个字符串。 n – 要比较的最大字符数。 该函数返回值如下： 如果返回值 &lt; 0，则表示 str1 小于 str2。 如果返回值 &gt; 0，则表示 str1 大于 str2。 如果返回值 = 0，则表示 str1 等于 str2。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main () &#123; char str1[15]; char str2[15]; int ret; strcpy(str1, &quot;abcdef&quot;); strcpy(str2, &quot;ABCDEF&quot;); ret = strncmp(str1, str2, 4); if(ret &lt; 0) &#123; printf(&quot;str1 小于 str2&quot;); &#125; else if(ret &gt; 0) &#123; printf(&quot;str2 小于 str1&quot;); &#125; else &#123; printf(&quot;str1 等于 str2&quot;); &#125; return(0); &#125; vector 容器 C++ 中的 vector 是一种序列容器，它允许你在运行时动态地插入和删除元素。 vector 是基于数组的数据结构，但它可以自动管理内存，这意味着你不需要手动分配和释放内存。 与 C++ 数组相比，vector 具有更多的灵活性和功能，使其成为 C++ 中常用的数据结构之一。 vector 是 C++ 标准模板库（STL）的一部分，提供了灵活的接口和高效的操作。 基本特性: 动态大小：vector 的大小可以根据需要自动增长和缩小。 连续存储：vector 中的元素在内存中是连续存储的，这使得访问元素非常快速。 可迭代：vector 可以被迭代，你可以使用循环（如 for 循环）来访问它的元素。 元素类型：vector 可以存储任何类型的元素，包括内置类型、对象、指针等。 使用场景： 当你需要一个可以动态增长和缩小的数组时。 当你需要频繁地在序列的末尾添加或移除元素时。 当你需要一个可以高效随机访问元素的容器时。 要使用 vector，首先需要包含 &lt;vector&gt; 头文件： #include &lt;vector&gt; 创建 Vector 创建一个 vector 可以像创建其他变量一样简单： std::vector&lt;int&gt; myVector; // 创建一个存储整数的空 vector 这将创建一个空的整数向量,也可以在创建时指定初始大小和初始值： std::vector&lt;int&gt; myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0） std::vector&lt;int&gt; myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10 或： std::vector&lt;int&gt; vec; // 默认初始化一个空的 vector std::vector&lt;int&gt; vec2 = &#123;1, 2, 3, 4&#125;; // 初始化一个包含元素的 vector 添加元素 可以使用 push_back 方法向 vector 中添加元素： myVector.push_back(7); // 将整数 7 添加到 vector 的末尾 访问元素 可以使用下标操作符 [] 或 at() 方法访问 vector 中的元素： int x = myVector[0]; // 获取第一个元素 int y = myVector.at(1); // 获取第二个元素 获取大小 可以使用 size() 方法获取 vector 中元素的数量： int size = myVector.size(); // 获取 vector 中的元素数量 迭代访问 可以使用迭代器遍历 vector 中的元素： for (auto it = myVector.begin(); it != myVector.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; 或者使用范围循环： for (int element : myVector) &#123; std::cout &lt;&lt; element &lt;&lt; &quot; &quot;; &#125; 删除元素 可以使用 erase() 方法删除 vector 中的元素： myVector.erase(myVector.begin() + 2); // 删除第三个元素 清空 Vector 可以使用 clear() 方法清空 vector 中的所有元素： myVector.clear(); // 清空 vector C++ 容器类 &lt;priority_queue&gt; 在 C++ 中，&lt;priority_queue&gt; 是标准模板库（STL）的一部分，用于实现优先队列。 优先队列是一种特殊的队列，它允许我们快速访问队列中具有最高（或最低）优先级的元素。 在 C++ 中，priority_queue 默认是一个最大堆，这意味着队列的顶部元素总是具有最大的值。 priority_queue 是一个容器适配器，它提供了对底层容器的堆操作。它不提供迭代器，也不支持随机访问。 语法 以下是 priority_queue 的基本语法： #include &lt;queue&gt; // 声明一个整型优先队列 priority_queue&lt;int&gt; pq; // 声明一个自定义类型的优先队列，需要提供比较函数 struct compare &#123; bool operator()(int a, int b) &#123; return a &gt; b; // 这里定义了最小堆 &#125; &#125;; priority_queue&lt;int, vector&lt;int&gt;, compare&gt; pq_min; 常用操作 empty(): 检查队列是否为空。 size(): 返回队列中的元素数量。 top(): 返回队列顶部的元素（不删除它）。 push(): 向队列添加一个元素。 pop(): 移除队列顶部的元素。 自定义优先级 如果你需要一个最小堆，可以通过自定义比较函数来实现： 实例 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; struct compare &#123; bool operator()(int a, int b) &#123; return a &gt; b; // 定义最小堆 &#125; &#125;; int main() &#123; // 创建一个自定义类型的优先队列，使用最小堆 std::priority_queue&lt;int, std::vector&lt;int&gt;, compare&gt; pq_min; // 向优先队列中添加元素 pq_min.push(30); pq_min.push(10); pq_min.push(50); pq_min.push(20); // 输出队列中的元素 std::cout &lt;&lt; &quot;最小堆中的元素：&quot; &lt;&lt; std::endl; while (!pq_min.empty()) &#123; std::cout &lt;&lt; pq_min.top() &lt;&lt; std::endl; pq_min.pop(); &#125; return 0; &#125; 输出结果： 最小堆中的元素： 10 20 30 50 &lt;priority_queue&gt; 是C++ STL中一个非常有用的容器，特别适合需要快速访问最高或最低优先级元素的场景。通过自定义比较函数，我们可以轻松地实现最大堆或最小堆。希望这篇文章能帮助初学者更好地理解和使用 priority_queue。 默认从大到小priority_queue&lt;int, std::vector&lt;int&gt;, greater&lt;&gt;&gt; pq_min; tr1/unordered_set tr1/unordered_map 自 C11 标准起，四种基于 哈希 实现的无序关联式容器正式纳入了 C 的标准模板库中，分别是：unordered_set，unordered_multiset，unordered_map，unordered_multimap。 编译器不支持 C++11 的使用方法 在 C11 之前，无序关联式容器属于 C 的 TR1 扩展。所以，如果编译器不支持 C++11，在使用时需要在头文件的名称中加入 tr1/ 前缀，并且使用 std::tr1 命名空间。如 #include &lt;unordered_map&gt; 需要改成 #include &lt;tr1/unordered_map&gt;；std::unordered_map 需要改为 std::tr1::unordered_map（如果使用 using namespace std;，则为 tr1::unordered_map）。 自定义哈希函数 哈希函数1： struct my_hash &#123; static uint64_t splitmix64(uint64_t x) &#123; x += 0x9e3779b97f4a7c15; x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb; return x ^ (x &gt;&gt; 31); &#125; size_t operator()(uint64_t x) const &#123; static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); &#125; // 针对 std::pair&lt;int, int&gt; 作为主键类型的哈希函数 size_t operator()(pair&lt;uint64_t, uint64_t&gt; x) const &#123; static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x.first + FIXED_RANDOM) ^ (splitmix64(x.second + FIXED_RANDOM) &gt;&gt; 1); &#125; &#125;; 哈希函数2： struct custom_hash &#123; static uint64_t splitmix64(uint64_t x) &#123; x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 7; x ^= x &lt;&lt; 17; return x; &#125; size_t operator()(const uint64_t x) const &#123; static uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); // 时间戳 return splitmix64(x + FIXED_RANDOM); &#125; &#125;; 写完自定义的哈希函数后，就可以通过 unordered_map&lt;int, int, my_hash&gt; my_map; 或者 unordered_map&lt;pair&lt;int, int&gt;, int, my_hash&gt; my_pair_map; 的定义方式将自定义的哈希函数传入容器了。 unordered_map&lt;il, int&gt; numbers; // 调负载因子和预留空间，防止hash冲突导致的性能下降 numbers.reserve(1024), numbers.max_load_factor(0.75); next_permutation 全排列 全排列是一种经典的组合数学问题，给定一个数字集合，求这个数字集合的所有排列。 next_permutation next_permutation 原型 template&lt; class BidirIt &gt; bool next_permutation( BidirIt first, BidirIt last ); next_permutation 使用 #include &lt;algorithm&gt; // next_permutation std::vector&lt;int&gt; v = &#123;1, 2, 3&#125;; do &#123; for (int i : v) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; &#125; while (std::next_permutation(v.begin(), v.end())); prev_permutation 上一个排列 prev_permutation 原型 template&lt; class BidirIt &gt; bool prev_permutation( BidirIt first, BidirIt last ); prev_permutation 使用 #include &lt;algorithm&gt; // prev_permutation std::vector&lt;int&gt; v = &#123;3, 2, 1&#125;; do &#123; for (int i : v) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; &#125; while (std::prev_permutation(v.begin(), v.end())); bitset 位运算 std::bitset 是标准库中的一个存储 0/1 的大小不可变容器。严格来讲，它并不属于 STL。 bitset count(): 返回 true 的数量。 size(): 返回 bitset 的大小。 test(pos): 它和 vector 中的 at() 的作用是一样的，和 [] 运算符的区别就是越界检查。 any(): 若存在某一位是 true 则返回 true，否则返回 false。 none(): 若所有位都是 false 则返回 true，否则返回 false。 all(): 若所有位都是 true 则返回 true，否则返回 false。 set(): 将整个 bitset 设置成 true。 set(pos, val = true): 将某一位设置成 true/false。 reset(): 将整个 bitset 设置成 false。 reset(pos): 将某一位设置成 false。相当于 set(pos, false)。 flip(): 翻转每一位。（0\\leftrightarrow1，相当于异或一个全是 1 的 bitset） flip(pos): 翻转某一位。 to_string(): 返回转换成的字符串表达。 to_ulong(): 返回转换成的 unsigned long 表达（long 在 NT 及 32 位 POSIX 系统下与 int 一样，在 64 位 POSIX 下与 long long 一样）。 to_ullong():（C++11 起）返回转换成的 unsigned long long 表达。 accumulate 和 reduce 累计 vector&lt;ll&gt; v(10); for (int i = 0; i &lt; 10; i++) &#123; v[i] = i + 1; &#125; cout &lt;&lt; accumulate(v.begin(), v.end(), 0) &lt;&lt; endl; cout &lt;&lt; reduce(v.begin(), v.end(), 0) &lt;&lt; endl; max_element, min_element 求最值 reverse反转序列 reverse(v.begin(), v.end()); nth_element 部分排序算法 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; int main() &#123; std::vector&lt;int&gt; v&#123;5, 6, 4, 3, 2, 6, 7, 9, 3&#125;; std::nth_element(v.begin(), v.begin() + v.size()/2, v.end()); std::cout &lt;&lt; &quot;The median is &quot; &lt;&lt; v[v.size()/2] &lt;&lt; &#x27;\\n&#x27;; std::nth_element(v.begin(), v.begin()+1, v.end(), std::greater&lt;int&gt;()); std::cout &lt;&lt; &quot;The second largest element is &quot; &lt;&lt; v[1] &lt;&lt; &#x27;\\n&#x27;; &#125; lower_bound, upper_bound 二分查找 lower_bound(v.begin(), v.end(), 20, cmp) upper_bound(v.begin(), v.end(), 20, cmp) partial_sum adjacent_difference 部分和与部分差 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;numeric&gt; int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;; std::vector&lt;int&gt; p(v.size()); std::vector&lt;int&gt; d(v.size()); std::partial_sum(v.begin(), v.end(), p.begin()); std::adjacent_difference(v.begin(), v.end(), d.begin()); for (int i : p) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; for (int i : d) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; iota 以始于 value 并重复地求值 ++value 的顺序递增值填充范围 [first, last) 。 #include &lt;iostream&gt; int main() &#123; std::vector&lt;int&gt; v(10); std::iota(v.begin(), v.end(), 1); for (int i : v) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; // output: 1 2 3 4 5 6 7 8 9 10 std::includes 判断一个序列是否包含另一个序列 #include &lt;iostream&gt; int main() &#123; std::vector&lt;int&gt; v1 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; std::vector&lt;int&gt; v2 = &#123;3, 4, 5&#125;; std::vector&lt;int&gt; v3 = &#123;3, 4, 5, 10&#125;; std::cout &lt;&lt; std::includes(v1.begin(), v1.end(), v2.begin(), v2.end()) &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; std::includes(v1.begin(), v1.end(), v3.begin(), v3.end()) &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; unique #include &lt;iostream&gt; int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 2, 3, 3, 3, 4, 4, 4, 4&#125;; auto last = std::unique(v.begin(), v.end()); for (auto i = v.begin(); i != last; ++i) &#123; std::cout &lt;&lt; *i &lt;&lt; &#x27; &#x27;; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;; return 0; &#125; rotate 旋转 进行元素范围上的左旋转 #include &lt;iostream&gt; int main() &#123; vector&lt;int&gt; a&#123;1,2,3,4,5,6,7,8,9&#125;; copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; std::rotate(a.begin(), a.begin()+5, a.end()); copy(a.begin(), a.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); return 0; &#125; 输出： 1 2 3 4 5 6 7 8 9 6 7 8 9 1 2 3 4 5 大小写转换 大写转小写 char c = tolower(a); 小写转大写 char c = toupper(a); advance 增加给定的迭代器 it 向前 n 个元素。 如果 n 为负，那么迭代器会自减。此时 InputIt 必须满足老式双向迭代器 (LegacyBidirectionalIterator) 的要求，否则行为未定义。 set a = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; auto it = a.begin(); advance(it, 3); cout &lt;&lt; *it &lt;&lt; endl; other: next() 和 prev()","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yuhiri.me/tags/STL/"}],"author":"yuhiri"},{"title":"黑题记录-2D Geometry 110 in 1!","slug":"黑题记录-2D-Geometry-110-in-1","date":"2024-10-08T08:12:06.000Z","updated":"2026-01-05T13:48:14.945Z","comments":true,"path":"2024/10/08/黑题记录-2D-Geometry-110-in-1/","permalink":"http://yuhiri.me/2024/10/08/%E9%BB%91%E9%A2%98%E8%AE%B0%E5%BD%95-2D-Geometry-110-in-1/","excerpt":"","text":"题目链接：https://vjudge.net/problem/UVA-12304 题面翻译 欢迎来到二维计算几何问题 合一~！ 你需要写一个程序，回答以下的询问。 请仔细阅读输入输出格式！ 询问 ：求外接圆 输入格式：CircumscribedCircle 输出格式：(x,y,r)，其中 描述圆心的位置， 表示圆的半径。 描述：给定三角形，顶点分别为 ，，，求出这个三角形的外接圆的圆心和半径。 约定：保证三点不共线。 询问 ：求内切圆 输入格式：InscribedCircle 输出格式：(x,y,r)，其中 描述圆心的位置， 表示圆的半径。 描述：给定三角形，顶点分别为 ，，，求出这个三角形的内切圆的圆心和半径。 约定：保证三点不共线。 询问 ：过一点求切线 输入格式：TangentLineThroughPoint 输出格式：[angle1,angle2] 输出一个列表（类似 Python 中的数组），列表中含有几个（或者 个）实数 ，以角度描述切线的倾斜角。注意单位是角度，你需要保证 。 你需要保证列表中的元素是升序排列的。 若无解，输出空列表 []。 描述：给定一个以 为圆心， 为半径的圆 和一个点 ，求出过 且与圆 相切的所有直线。 询问 ：求与一条已知直线相切、过已知点且固定半径的圆 输入格式：CircleThroughAPointAndTangentToALineWithRadius = 输出格式：[(x1,y1),(x2,y2)] 输出一个列表（类似 Python 中的数组），列表中含有几个（或者 个）二元组 ，描述一个圆的圆心。 你需要保证列表中的元素以 为第一关键字， 为第二关键字升序排列。 若无解，输出空列表 []。 描述：给定过 和 的直线 ，点 和半径 。你需要求出所有的圆 ，满足以下条件： 与 相切。 点 在圆 上。 的半径为 。 询问 ：求与两条已知直线相切且固定半径的圆 输入格式：CircleTangentToTwoLinesWithRadius 输出格式：[(x1,y1),(x2,y2)] 同询问 中的输出。 输出一个列表（类似 Python 中的数组），列表中含有几个（或者 个）二元组 ，描述一个圆的圆心。 你需要保证列表中的元素以 为第一关键字， 为第二关键字升序排列。 若无解，输出空列表 []。 描述：给定过 和 的直线 ，过 和 的直线 和半径 。你需要求出所有的圆 ，满足以下条件： 与 和 都相切。 的半径为 。 约定：保证 不与 平行。 询问 ：求固定半径的公共外切圆 输入格式：CircleTangentToTwoDisjointCirclesWithRadius 输出格式：[(x1,y1),(x2,y2)] 同询问 中的输出。 输出一个列表（类似 Python 中的数组），列表中含有几个（或者 个）二元组 ，描述一个圆的圆心。 你需要保证列表中的元素以 为第一关键字， 为第二关键字升序排列。 若无解，输出空列表 []。 描述：给定圆 ，半径为 ，圆心坐标为 和圆 ，半径为 ，圆心坐标为 。且给定 。你需要求出所有的圆 ，满足以下条件： 与 和 外切。也就是说， 不能把 或者 包含在（）内。 的半径为 。 请注意： 输出时，对于列表元素是实数的情况，你需要保证列表中的元素是升序的。 输出时，对于列表元素是二元组 的情况，你需要保证这些二元组以 为第一关键字， 为第二关键字升序排列。 无解的时候输出空列表 []。 你的输出中不应包含空格。 每个输出的数字保留 位小数。 输入格式 本题有多组数据。数据组数不超过 。 对于每行，有一个询问，格式如上所述。保证所有输入的数字均为整数，且绝对值不大于 。 数据以 EOF（文件终止符）结尾。 输出格式 对于每个询问，输出结果，格式如上所述。 每个输出的数字应保留 位小数。 对于每个列表，以中括号 [] 包裹；对于每个二元组，以小括号 () 包裹。你的输出中不应包含空格。 题目描述 PDF 输入格式 输出格式 样例 #1 样例输入 #1 CircumscribedCircle 0 0 20 1 8 17 InscribedCircle 0 0 20 1 8 17 TangentLineThroughPoint 200 200 100 40 150 TangentLineThroughPoint 200 200 100 200 100 TangentLineThroughPoint 200 200 100 270 210 CircleThroughAPointAndTangentToALineWithRadius 100 200 75 190 185 65 100 CircleThroughAPointAndTangentToALineWithRadius 75 190 75 190 185 65 100 CircleThroughAPointAndTangentToALineWithRadius 100 300 100 100 200 100 100 CircleThroughAPointAndTangentToALineWithRadius 100 300 100 100 200 100 99 CircleTangentToTwoLinesWithRadius 50 80 320 190 85 190 125 40 30 CircleTangentToTwoDisjointCirclesWithRadius 120 200 50 210 150 30 25 CircleTangentToTwoDisjointCirclesWithRadius 100 100 80 300 250 70 50 样例输出 #1 (9.734940,5.801205,11.332389) (9.113006,6.107686,5.644984) [53.977231,160.730818] [0.000000] [] [(112.047575,299.271627),(199.997744,199.328253)] [(-0.071352,123.937211),(150.071352,256.062789)] [(100.000000,200.000000)] [] [(72.231286,121.451368),(87.815122,63.011983),(128.242785,144.270867),(143.826621,85.831483)] [(157.131525,134.836744),(194.943947,202.899105)] [(204.000000,178.000000)] AC代码 #include &lt;ostream&gt; #include &lt;utility&gt; #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; using ld = long double; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return nullptr; }(); constexpr ld eps = 1e-6; inline int checkZero(const double x) { if (-eps &lt;= x &amp;&amp; x &lt;= eps) return 0; return x &gt; 0 ? 1 : -1; } struct Point { ld x, y; Point() : x(0), y(0) {} Point(const ld x, const ld y): x(x), y(y) { } ~Point() = default; Point(const Point&amp; other) = default; Point(Point&amp;&amp; other) noexcept: x(other.x), y(other.y) { } Point&amp; operator=(const Point&amp; other) { if (this == &amp;other) return *this; x = other.x; y = other.y; return *this; } Point&amp; operator=(Point&amp;&amp; other) noexcept { if (this == &amp;other) return *this; x = other.x; y = other.y; return *this; } friend istream&amp; operator&gt;&gt;(istream&amp; in, Point&amp; o) { return in &gt;&gt; o.x &gt;&gt; o.y; } friend bool operator&lt;(const Point&amp; lhs, const Point&amp; rhs) { return lhs.x == rhs.x ? lhs.y &lt; rhs.y : lhs.x &lt; rhs.x; } Point operator+(const Point&amp; t) const { return {x + t.x, y + t.y}; } Point operator-(const Point&amp; t) const { return {x - t.x, y - t.y}; } Point operator-() const { return {-x, -y}; } Point operator*(const ld t) const { return {x * t, y * t}; } //数乘 void operator*=(const ld t) { x *= t, y *= t; } //数乘 Point operator/(const ld t) const { return checkZero(t) == 0 ? Point() : Point(x / t, y / t); } void operator/=(const ld t) { x /= t, y /= t; } ld norm() const { return sqrt(x * x + y * y); } Point rotate() { return *this = {y, -x}; } }; using Vec = Point; struct Line { Point s; Vec v; Line() = default; Line(Point s, Vec v): s(std::move(s)), v(std::move(v)) { } Line(const Line&amp; other) = default; ~Line() = default; Line(Line&amp;&amp; other) noexcept : s(std::move(other.s)), v(std::move(other.v)) { } Line&amp; operator=(const Line&amp; other) { if (this == &amp;other) return *this; s = other.s; v = other.v; return *this; } Line&amp; operator=(Line&amp;&amp; other) noexcept { if (this == &amp;other) return *this; s = std::move(other.s); v = std::move(other.v); return *this; } }; inline ld cross(const Point&amp; a, const Point&amp; b) { return a.x * b.y - a.y * b.x; } //叉积 inline ld dot(const Point&amp; a, const Point&amp; b) { return a.x * b.x + a.y * b.y; } //点积 inline ld dis(const Point&amp; a, const Point&amp; b) { return sqrt(dot(a - b, a - b)); } //距离 inline ld dis(const Point&amp; p, const Line&amp; l) { const Vec a = p - l.s; const ld d = dot(a, l.v) / l.v.norm(); return sqrt(pow(a.norm(), 2) - d * d); } inline Point inter(const Line&amp; l1, const Line&amp; l2) { const Point t1 = l1.s + l1.v; const ld s1 = cross(l2.v, l1.s - l2.s); const ld s2 = cross(t1 - l2.s, l2.v); const ld t = s1 / (s1 + s2); return l1.s + l1.v * t; } inline string streamput(const vector&lt;Point&gt;&amp; v) { stringstream ss; ss &lt;&lt; fixed &lt;&lt; setprecision(6); for (const auto&amp; l: v) ss &lt;&lt; '(' &lt;&lt; l.x &lt;&lt; ',' &lt;&lt; l.y &lt;&lt; ')' &lt;&lt; ','; string s = ss.str(); s.pop_back(); return s; } inline double CheckAngleAndChange(double angle) { // Change to [0, 180) if (checkZero(angle) == -1) while (checkZero(angle) == -1) angle += 180.0; else if (checkZero(angle - 180.0) != -1) while (checkZero(angle - 180.0) != -1) angle -= 180.0; return angle; } inline void CircumscribedCircle() { Point p1, p2, p3; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3; const Line l12((p1 + p2) / 2.0, (p1 - p2).rotate()); const Line l13((p1 + p3) / 2.0, (p1 - p3).rotate()); const Point o = inter(l12, l13); const ld r = dis(o, p1); cout &lt;&lt; '(' &lt;&lt; o.x &lt;&lt; ',' &lt;&lt; o.y &lt;&lt; ',' &lt;&lt; r &lt;&lt; ')' &lt;&lt; '\\n'; } inline void InscribedCircle() { Point p1, p2, p3; cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3; const Line c12(p3, (p1 - p3) / dis(p1, p3) + (p2 - p3) / dis(p2, p3)); const Line c13(p2, (p1 - p2) / dis(p1, p2) + (p3 - p2) / dis(p3, p2)); const Point o = inter(c12, c13); const ld r = dis(o, Line{p1, p2 - p1}); cout &lt;&lt; '(' &lt;&lt; o.x &lt;&lt; ',' &lt;&lt; o.y &lt;&lt; ',' &lt;&lt; r &lt;&lt; ')' &lt;&lt; '\\n'; } inline void TangentLineThroughPoint() { Point p, o; ld r; cin &gt;&gt; o &gt;&gt; r &gt;&gt; p; const ld d = dis(o, p); if (d &lt; r) { cout &lt;&lt; \"[]\\n\"; return; } if (fabs(d - r) &lt; eps) { auto &amp;&amp;res = (p - o).rotate(); int x = res.x, y = res.y; ld ans = atan2(y, x); ans *= 180 / M_PI; ans = CheckAngleAndChange(ans); cout &lt;&lt; '[' &lt;&lt; ans &lt;&lt; ']' &lt;&lt; '\\n'; } else { const Vec pv = p - o; const ld cha = asin(r / pv.norm()); const ld ac = atan2(pv.y, pv.x); vector&lt;ld&gt; ans(2); ans[0] = (ac + cha) * 180 / M_PI; ans[1] = (ac - cha) * 180 / M_PI; for (ld&amp; a: ans) a = CheckAngleAndChange(a); sort(ans.begin(), ans.end()); cout &lt;&lt; '[' &lt;&lt; ans[0] &lt;&lt; ',' &lt;&lt; ans[1] &lt;&lt; ']' &lt;&lt; '\\n'; } } inline void CircleThroughAPointAndTangentToALineWithRadius() { Point p, a, b; ld r; cin &gt;&gt; p &gt;&gt; a &gt;&gt; b &gt;&gt; r; const Line ab(a, b - a); const ld d = dis(p, ab); if (d - r * 2.0 &gt; eps) { cout &lt;&lt; \"[]\\n\"; return; } Vec c = ab.v; c.rotate(); c /= c.norm(); c *= r; vector&lt;pair&lt;Line, ld&gt;&gt; lines = &lt;!--swig￼0--&gt;; lines[0].second = dis(p, lines[0].first); lines[1].second = dis(p, lines[1].first); if (lines[1].second - r &gt; eps) lines.erase(lines.begin() + 1, lines.end()); if (lines[0].second - r &gt; eps) lines.erase(lines.begin(), lines.begin() + 1); vector&lt;Point&gt; ans; for (auto&amp; line: lines) { Line &amp;l = line.first; ld &amp;dist = line.second; const ld k = sqrt(fabs(r * r - dist * dist)); Vec tmp = l.v; Point pa = inter(l, Line(p, tmp.rotate())); if (k &lt; eps) { ans.push_back(pa); continue; } Vec vp = l.v / l.v.norm() * k; ans.push_back(pa + vp); ans.push_back(pa - vp); } sort(ans.begin(), ans.end()); cout &lt;&lt; '[' &lt;&lt; streamput(ans) &lt;&lt; ']' &lt;&lt; '\\n'; } inline void CircleTangentToTwoLinesWithRadius() { Line a, b; ld r; cin &gt;&gt; a.s &gt;&gt; a.v &gt;&gt; b.s &gt;&gt; b.v &gt;&gt; r; a.v = a.v - a.s, b.v = b.v - b.s; Vec ta = a.v / a.v.norm(), tb = b.v / b.v.norm(); ta.rotate(), tb.rotate(); ta *= r, tb *= r; vector&lt;Point&gt; ans; ans.reserve(4); ans.push_back(inter({a.s + ta, a.v}, {b.s + tb, b.v})); ans.push_back(inter({a.s + ta, a.v}, {b.s - tb, b.v})); ans.push_back(inter({a.s - ta, a.v}, {b.s + tb, b.v})); ans.push_back(inter({a.s - ta, a.v}, {b.s - tb, b.v})); sort(ans.begin(), ans.end()); cout &lt;&lt; '[' &lt;&lt; streamput(ans) &lt;&lt; ']' &lt;&lt; '\\n'; } inline void CircleTangentToTwoDisjointCirclesWithRadius() { Point a, b; ld r1, r2, r; cin &gt;&gt; a &gt;&gt; r1 &gt;&gt; b &gt;&gt; r2 &gt;&gt; r; ld d = dis(a, b); r1 += r, r2 += r; if (d - (r1 + r2) &gt;= eps || fabs(r2 - r1) - d &gt;= eps) { cout &lt;&lt; \"[]\\n\"; return; } if (fabs(d - (r1 + r2)) &lt; eps || d - fabs(r2 - r1) &lt; eps) { const Vec v = (b - a) / d * r1; Point o = a + v; cout &lt;&lt; \"[(\" &lt;&lt; o.x &lt;&lt; ',' &lt;&lt; o.y &lt;&lt; \")]\" &lt;&lt; '\\n'; return; } ld ap = (pow(r1, 2) + pow(d, 2) - pow(r2, 2)) / (2 * d); Point p = a + (b - a) / d * ap; ld k = sqrt(r1 * r1 - ap * ap); Vec v = (b - a).rotate() / d * k; vector&lt;Point&gt; ans = {p + v, p - v}; sort(ans.begin(), ans.end()); cout &lt;&lt; '[' &lt;&lt; streamput(ans) &lt;&lt; ']' &lt;&lt; '\\n'; } int main() { // DEBUG // freopen(\"../in.txt\", \"r\", stdin); string s; unordered_map&lt;string, char&gt; m{ {\"CircumscribedCircle\", 1}, {\"InscribedCircle\", 2}, {\"TangentLineThroughPoint\", 3}, {\"CircleThroughAPointAndTangentToALineWithRadius\", 4}, {\"CircleTangentToTwoLinesWithRadius\", 5}, {\"CircleTangentToTwoDisjointCirclesWithRadius\", 6} }; cout &lt;&lt; fixed &lt;&lt; setprecision(6); while (cin &gt;&gt; s) { switch (m[s]) { case 1: CircumscribedCircle(); break; case 2: InscribedCircle(); break; case 3: TangentLineThroughPoint(); break; case 4: CircleThroughAPointAndTangentToALineWithRadius(); break; case 5: CircleTangentToTwoLinesWithRadius(); break; case 6: CircleTangentToTwoDisjointCirclesWithRadius(); } } return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"author":"yuhiri"},{"title":"dinic 算法","slug":"Dinic-算法","date":"2024-09-02T07:04:06.000Z","updated":"2026-01-05T13:46:12.814Z","comments":true,"path":"2024/09/02/Dinic-算法/","permalink":"http://yuhiri.me/2024/09/02/Dinic-%E7%AE%97%E6%B3%95/","excerpt":"","text":"Dinic算法 Dinic 算法，它由 Dinitz 在 1970 年提出。Dinic 算法可以找到网络中的最大流。Dinic 算法的时间复杂度低于 Edmonds-Karp 算法。 时间复杂度： (V：点数，E：边数) 算法介绍 层次图：就是把原图中的点按照点到源的距离分“层”，只保留不同层之间的边的图。 算法流程 算法流程 根据残量网络计算层次图（level graph）。 在层次图中使用DFS进行增广直到不存在增广路。 重复以上步骤直到无法增广。 LuoGu P1343 地震逃生 题目链接: https://vjudge.net/problem/洛谷-P1343 题目描述 汶川地震发生时，四川**中学正在上课，一看地震发生，老师们立刻带领 名学生逃跑，整个学校可以抽象地看成一个有向图，图中有 个点， 条边。 号点为教室， 号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从 号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生， 名学生分几批才能运完。 输入格式 第一行三个整数 ； 以下 行，每行三个整数 （，）描述一条边，分别代表从 点到 点有一条边，且可容纳 名学生。 输出格式 两个整数，分别表示每批最多能运出多少个学生， 名学生分几批才能运完。如果无法到达目的地（ 号点）则输出 Orz Ni Jinan Saint Cow!。 样例 #1 样例输入 6 7 7 1 2 1 1 4 2 2 3 1 4 5 1 4 3 1 3 6 2 5 6 1 样例输出 3 3 提示 【数据范围】 对于 的数据，，，。 题解 #include &lt;bits/stdc++.h&gt; using namespace std; using ll = long long; static const auto _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return nullptr; }(); #define INF INT_MAX constexpr int N = 210, M = 4e3 + 10; int n, m, tot; int st, ed; // start, end int d[N], cur[N]; int head[N], nxt[M], var[M], weight[M]; int idx = -1; inline void add(const int x, const int y, const int z) { nxt[++idx] = head[x], head[x] = idx, var[idx] = y; weight[idx] = z; } // get level graph inline bool bfs() { memset(d, -1, sizeof(int) * (ed + 1)); d[st] = 0; queue&lt;int&gt; q; q.push(st); cur[st] = head[st]; // 当前弧的优化 while (!q.empty()) { int x = q.front(); q.pop(); for (int i = head[x]; ~i; i = nxt[i]) { int y = var[i]; // 未标明层级，且边权不为0的有效边 if (d[y] == -1 &amp;&amp; weight[i]) { d[y] = d[x] + 1; cur[y] = head[y]; // 当前弧的优化，find时使用 if (y == ed) return true; // 能走到终点 q.push(y); } } } return false; // 不能走到终点 } // find block flow inline int find(int x, int limit) { if (x == ed) return limit; int res = limit; for (int i = cur[x]; ~i; i = nxt[i]) { int y = var[i]; cur[x] = i; // 当前弧的优化 if (d[y] == d[x] + 1 &amp;&amp; weight[i]) { int tmp = find(y, min(weight[i], res)); if (!tmp) d[y] = -1; // 残枝优化 res -= tmp; weight[i] -= tmp; weight[i ^ 1] += tmp; // 反向流 } } return limit - res; } inline int dinic() { int res = 0, flow; // 如果能找到增广路 while (bfs()) { while ((flow = find(st,INF))) { res += flow; } } return res; } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; tot; st = 1; ed = n; memset(head, -1, sizeof(int) * (ed + 1)); for (int i = 1, a, b, c; i &lt;= m; ++i) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); // 偶数，有向边 add(b, a, 0); // 奇数，反向边 } int res = dinic(); // dinic if (!res) cout &lt;&lt; \"Orz Ni Jinan Saint Cow!\"; else cout &lt;&lt; res &lt;&lt; ' ' &lt;&lt; (int) ceil(tot * 1.0 / res) &lt;&lt; '\\n'; return 0; }","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"网络流","permalink":"http://yuhiri.me/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"Dinic","slug":"Dinic","permalink":"http://yuhiri.me/tags/Dinic/"},{"name":"图论","slug":"图论","permalink":"http://yuhiri.me/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"yuhiri"},{"title":"开源项目 LinuxMirrors 让换源更简单","slug":"open-source-LinuxMirrors","date":"2024-06-25T15:39:53.000Z","updated":"2026-01-05T13:44:42.691Z","comments":true,"path":"2024/06/25/open-source-LinuxMirrors/","permalink":"http://yuhiri.me/2024/06/25/open-source-LinuxMirrors/","excerpt":"","text":"LinuxMirrors 以前安装Linux，因为国内的网络环境，总是需要更换系统软件源，这个过程总是很繁琐，而且容易出错。现在找到了一个开源项目，可以一条命令就可以更换系统软件源，非常方便（推荐+1 qwq 项目地址 官网: LinuxMirrors GitHub: LinuxMirrors Gitee: LinuxMirrors 使用方法 命令如下： bash &lt;(curl -sSL https://linuxmirrors.cn/main.sh) 需使用 ROOT 用户执行脚本 切换命令为 sudo -i 或 su root，不同系统环境使用的命令不一样，因为有些系统没有在初始安装时为 ROOT 用户设置固定密码（例如Ubuntu）所以需要使用 sudo 指令来提权 root 密码设置： sudo passwd root 官方介绍 GNU/Linux 更换系统软件源脚本，让换源更简单 多软件源适配 考察了国内镜像站的系统适配情况，测试了下载速度与IPv6协议的兼容性 另外，提供了全网收集的中国大陆教育网镜像站和海外镜像站供选择 脚本一键运行 脚本使换源变得更简单，通过交互默认进行更换，并根据用户选择自动配置 同时，提供了强大的命令选项，可用于自动化项目以实现无交互操作 开源，MIT 项目已设立开源许可协议，传播时请在显著位置标注来源和作者 请尊重作者的知识成果，建议通过命令直接调用脚本","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yuhiri.me/tags/Linux/"},{"name":"镜像源","slug":"镜像源","permalink":"http://yuhiri.me/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"},{"name":"tools","slug":"tools","permalink":"http://yuhiri.me/tags/tools/"}],"author":"yuhiri"},{"title":"Task Plot 题解","slug":"POI2011-WYK-Plot-Solved","date":"2024-06-18T11:47:27.000Z","updated":"2026-01-05T13:44:32.375Z","comments":true,"path":"2024/06/18/POI2011-WYK-Plot-Solved/","permalink":"http://yuhiri.me/2024/06/18/POI2011-WYK-Plot-Solved/","excerpt":"","text":"Task Plot 原题链接、原题链接2 题目描述 We call any sequence of points in the plane a plot. We intend to replace a given plot with another that will have at most points () in such a way that it “resembles” the original plot best. The new plot is created as follows. The sequence of points can be partitioned into () contiguous subsequences: where ,and afterwards each subsequence , for ,is replaced by a new point . In that case we say that each of the points has been contracted to the point . As a result a new plot, represented by the points , is created. The measure of such plot’s resemblance to the original is the maximum distance of all the points to the point it has been contracted to: where denotes the distance between and , given by the well-known formula: An exemplary plot and the new plot , where are contracted to , whereas to . For a given plot consisting of points, you are to find the plot that resembles it most while having at most points, where the partitioning into contiguous subsequences is arbitrary. Due to limited precision of floating point operations, a result is deemed correct if its resemblance to the given plot is larger than the optimum resemblance by at most . 给定n个点，要求把n个点分成不多于m段，使得求出每段的最小覆盖圆的半径后，最大的半径最小。 输入格式 In the first line of the standard input there are two integers and , , separated by a single space. Each of the following lines holds two integers, separated by a single space. The -th line gives ,, denoting the coordinates of the point . 输出格式 In the first line of the standard output one real number should be printed out, the resemblance measure of the plot found to the original one. In the second line of the standard output there should be another integer , . Next, the following lines should specify the coordinates of the points ,one point per line. Thus the -th line should give two real numbers and , separated by a single space, that denote the coordinates of the point .All the real numbers should be printed with at most 15 digits after the decimal point. 样例 #1 样例输入 #1 7 2 2 0 0 4 4 4 4 2 8 2 11 3 14 2 样例输出 #1 3.00000000 2 2.00000000 1.76393202 11.00000000 1.99998199 提示 给定n个点，要求把n个点分成不多于m段，使得求出每段的最小覆盖圆的半径后，最大的半径最小。 题目大意 1.题意：给一个有 个元素的点集，要求把n个点划分成不多于m个子集，使得求出每点集的最小覆盖圆的半径后，使得最大的半径最小。 解题思路 采取二分答案的思路，对圆半径进行二分答案，然后对于每个圆半径，我们可以采取随机增量法，随机增量法是一种求解最小圆覆盖的方法，其思路是随机选取一个点，然后遍历所有点，如果有点不在圆内，那么就更新圆心，然后再次遍历所有点，如果有点不在圆内，那么就更新圆心和半径，然后再次遍历所有点，如果有点不在圆内，那么就更新圆心和半径，这样就可以求出最小圆覆盖的圆心和半径。 不会随机增量法的先去做最小圆覆盖 check 函数用于判断是否可以将所有点分成不多于 m 个子集，使得求出每个子集的最小覆盖圆的半径后，最大的半径不超过 lim。 check 函数内部，同样使用二分答案，对于每个子集，使用随机增量法求出最小圆覆盖的圆心和半径，然后判断是否满足条件。 bool check(ld lim) { cnt = 0; int ans; for (int i = 1; i &lt;= n; i = ans + 1) { int k; for (k = 1; i + (1 &lt;&lt; k) - 1 &lt;= n; ++k) { random_increment(i, i + (1 &lt;&lt; k) - 1); if (d &gt; lim + eps) break; } ans = i; int l = i + (1 &lt;&lt; (k - 1)) - 1, r = min(n, i + (1 &lt;&lt; k) - 1); while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; random_increment(i, mid); if (d &lt; lim + eps) l = mid + 1, ans = mid; else r = mid - 1; } ++cnt; res[cnt][0] = i, res[cnt][1] = ans; if (cnt &gt; m) return false; } return true; } 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;random&gt; #include &lt;iomanip&gt; using namespace std; using ld = long double; struct node { ld x, y; inline ld length() const { return fabs(pow(x, 2) + pow(y, 2)); } inline void transfer() { x = -x; swap(x, y); } node operator/(ld v) const { return node{x / v, y / v}; } node operator*(ld v) const { return node{x * v, y * v}; } friend node operator+(node &amp;n1, node &amp;n2) { return node{n1.x + n2.x, n1.y + n2.y}; } friend node operator+(node &amp;n1, node &amp;&amp;n2) { return node{n1.x + n2.x, n1.y + n2.y}; } friend node operator-(node &amp;n1, node &amp;n2) { return node{n1.x - n2.x, n1.y - n2.y}; } friend node operator*(node &amp;n1, node &amp;n2) { return node{n1.x * n2.x, n1.y * n2.y}; } }; inline ld dis(node &amp;p1, node &amp;p2) { return sqrt((p1 - p2).length()); } inline ld cross(const node &amp;p1, node &amp;p2) { return (p1.x * p2.y) - (p1.y * p2.x); } inline node get_circle(node &amp;p1, node &amp;p2) { return (p1 + p2) / 2.0; } inline node get_circle(node &amp;p1, node &amp;p2, node &amp;p3) { node v1 = p2 - p1, v2 = p3 - p1; v1.transfer(), v2.transfer(); node m1 = (p1 + p2) / 2.0, m2 = (p1 + p3) / 2.0; ld t = cross(m2 - m1, v2) / cross(v1, v2); return m1 + (v1 * t); } const ld eps = 1e-10; const int N = 1e5 + 5; int n, m, cnt; int res[N][2]; node v[N], ps[N]; node o{}; ld d; random_device rd; mt19937 g(rd()); // 随机增量 inline void random_increment(int l, int r) { copy(ps + l, ps + r + 1, v); int len = r + 1 - l; shuffle(v, v + len, g); o = v[0], d = 0; for (int i = 0; i &lt; len; ++i) { if (dis(o, v[i]) &gt; d + eps) { o = v[i], d = 0; for (int j = 0; j &lt; i; ++j) { if (dis(o, v[j]) &gt; d + eps) { o = get_circle(v[i], v[j]); d = dis(o, v[j]); for (int k = 0; k &lt; j; ++k) { if (dis(o, v[k]) &gt; d + eps) { o = get_circle(v[i], v[j], v[k]); d = dis(o, v[i]); } } } } } } } bool check(ld lim) { cnt = 0; int ans; for (int i = 1; i &lt;= n; i = ans + 1) { int k; for (k = 1; i + (1 &lt;&lt; k) - 1 &lt;= n; ++k) { random_increment(i, i + (1 &lt;&lt; k) - 1); if (d &gt; lim + eps) break; } ans = i; int l = i + (1 &lt;&lt; (k - 1)) - 1, r = min(n, i + (1 &lt;&lt; k) - 1); while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; random_increment(i, mid); if (d &lt; lim + eps) l = mid + 1, ans = mid; else r = mid - 1; } ++cnt; res[cnt][0] = i, res[cnt][1] = ans; if (cnt &gt; m) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; ps[i].x &gt;&gt; ps[i].y; } random_increment(1, n); ld l = 0, r = d; if (m &gt; 1) { while (r - l &gt; eps) { ld mid = (l + r) / 2.0; if (check(mid)) r = mid; else l = mid; } } check(r); cout &lt;&lt; fixed &lt;&lt; setprecision(8); cout &lt;&lt; r &lt;&lt; '\\n' &lt;&lt; cnt &lt;&lt; '\\n'; for (int i = 1; i &lt;= cnt; ++i) { random_increment(res[i][0], res[i][1]); cout &lt;&lt; o.x &lt;&lt; ' ' &lt;&lt; o.y &lt;&lt; '\\n'; } return 0; } 复杂度分析 时间复杂度： 相关标准库和函数 函数 random_device mt19937 shuffle 库 random iomanip","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"随机增量法","slug":"随机增量法","permalink":"http://yuhiri.me/tags/%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F%E6%B3%95/"},{"name":"二分套二分","slug":"二分套二分","permalink":"http://yuhiri.me/tags/%E4%BA%8C%E5%88%86%E5%A5%97%E4%BA%8C%E5%88%86/"}],"author":"yuhiri"},{"title":"给定背景颜色的良好文本前景色","slug":"to-decide-font-color-in-white-or-black-depending-on-background-color","date":"2024-05-09T00:43:05.000Z","updated":"2026-01-05T13:43:37.035Z","comments":true,"path":"2024/05/09/to-decide-font-color-in-white-or-black-depending-on-background-color/","permalink":"http://yuhiri.me/2024/05/09/to-decide-font-color-in-white-or-black-depending-on-background-color/","excerpt":"","text":"引入 之前想做一个网页色卡，需要背景颜色和文字颜色对比良好。已获得更好视觉效果。这里分享一下如何根据背景颜色自动选择黑色或白色作为文本颜色。 就像这样 /* 用于填充字符串 `str` 到指定长度 `len`，默认为 2 例如：padZero(&#x27;F&#x27;, 2) =&gt; &#x27;0F&#x27; */ function padZero(str, len) &#123; len = len || 2; const zeros = new Array(len).join(&#x27;0&#x27;); return (zeros + str).slice(-len); &#125; function invertColor(hex, bw) &#123; if (hex.indexOf(&#x27;#&#x27;) === 0) &#123; hex = hex.slice(1); &#125; // convert 3-digit hex to 6-digits. if (hex.length === 3) &#123; hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]; &#125; if (hex.length !== 6) &#123; throw new Error(&#x27;Invalid HEX color.&#x27;); &#125; let r = parseInt(hex.slice(0, 2), 16), g = parseInt(hex.slice(2, 4), 16), b = parseInt(hex.slice(4, 6), 16); if (bw) &#123; // https://stackoverflow.com/a/3943023/112731 return (r * 0.299 + g * 0.587 + b * 0.114) &gt; 186 ? &#x27;#000000&#x27; : &#x27;#FFFFFF&#x27;; &#125; // invert color components r = (255 - r).toString(16); g = (255 - g).toString(16); b = (255 - b).toString(16); // pad each with zeros and return return &quot;#&quot; + padZero(r) + padZero(g) + padZero(b); &#125; 通过调用 invertColor 函数，传入背景颜色的 HEX 值，第二个参数为 true 时，返回黑色或白色的 HEX 值。 当第二个参数为 false 时，返回背景颜色的反色 HEX 值。 这里(r * 0.299 + g * 0.587 + b * 0.114) &gt; 186 186 的阈值是基于理论的，但可以根据口味进行调整。 还实现了一个Java类HexColor, 它可以实现合适文本前景色效果。 package cn.yuhiri.tools; import java.io.Serial; import java.io.Serializable; import java.util.Objects; /** * HexColor class * A class to represent hex color * @version 1.0.0 * @since 1.0.0 * @auther yuhiri * @see &lt;a href=&quot;https://yuhiri.me&quot;&gt;yuhiri&#x27;s blog&lt;/a&gt; */ public class HexColor implements Serializable &#123; @Serial private static final long serialVersionUID = -691002720950767165L; private String hexColor; private int r, g, b; private static final String HEX_REGEX = &quot;(^#|^)([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$&quot;; /** * Convert 3-digit hex color to 6-digit hex color * * @return 6-digit hex color */ private String doubleHex() &#123; return hexColor.substring(0, 1).repeat(2) + hexColor.substring(1, 2).repeat(2) + hexColor.substring(2, 3).repeat(2); &#125; /** * Constructor * * @param hexColor 3-digit or 6-digit hex color */ public HexColor(String hexColor) &#123; hexColor = hexColor.replace(&quot;#&quot;, &quot;&quot;).toUpperCase(); if (!hexColor.matches(HEX_REGEX)) &#123; throw new IllegalArgumentException(&quot;Invalid hex color&quot;); &#125; if (hexColor.length() == 3) &#123; this.hexColor = doubleHex(); &#125; else &#123; this.hexColor = hexColor; &#125; this.r = Integer.parseInt(this.hexColor.substring(0, 2), 16); this.g = Integer.parseInt(this.hexColor.substring(2, 4), 16); this.b = Integer.parseInt(this.hexColor.substring(4, 6), 16); &#125; /** * Constructor * Default color: #000000 */ public HexColor() &#123; hexColor = &quot;000000&quot;; r = 0; g = 0; b = 0; &#125; /** * Constructor * * @param r red value * @param g green value * @param b blue value */ public HexColor(int r, int g, int b) &#123; if (r &lt; 0 || r &gt; 255 || g &lt; 0 || g &gt; 255 || b &lt; 0 || b &gt; 255) &#123; throw new IllegalArgumentException(&quot;Invalid RGB value&quot;); &#125; this.r = r; this.g = g; this.b = b; this.hexColor = padZero(Integer.toHexString(r)) + padZero(Integer.toHexString(g)) + padZero(Integer.toHexString(b)); &#125; /** * Pad zero to the left of a string * * @param str input string * @return string with zero padded */ private String padZero(String str) &#123; return String.format(&quot;%&quot; + 2 + &quot;s&quot;, str).replace(&#x27; &#x27;, &#x27;0&#x27;).toUpperCase(); &#125; /** * Invert color * * @param bw whether to return black or white * @return inverted color */ public String invertColor(boolean bw) &#123; if (this.hexColor == null) &#123; return null; &#125; if (bw) &#123; int threshold = 186; int bgDelta = (int) (r * 0.299 + g * 0.587 + b * 0.114); return (bgDelta &gt; threshold) ? &quot;#000&quot; : &quot;#FFF&quot;; &#125; return &quot;#&quot; + padZero(Integer.toHexString(255 - r)) + padZero(Integer.toHexString(255 - g)) + padZero(Integer.toHexString(255 - b)); &#125; /** * Get red value * * @return red value */ public String getHexColor() &#123; return hexColor; &#125; /** * Set hex color * * @param hexColor 3-digit or 6-digit hex color */ public void setHexColor(String hexColor) &#123; if (!hexColor.matches(HEX_REGEX)) &#123; throw new IllegalArgumentException(&quot;Invalid hex color&quot;); &#125; hexColor = hexColor.replace(&quot;#&quot;, &quot;&quot;).toUpperCase(); if (hexColor.length() == 3) &#123; hexColor = this.doubleHex(); &#125; this.hexColor = hexColor; &#125; /** * Set red value * * @param r red value * range: 0-255 * @param g green value * range: 0-255 * @param b blue value * range: 0-255 */ public void setHexColor(int r, int g, int b) &#123; if (r &lt; 0 || r &gt; 255 || g &lt; 0 || g &gt; 255 || b &lt; 0 || b &gt; 255) &#123; throw new IllegalArgumentException(&quot;Invalid RGB value&quot;); &#125; this.r = r; this.g = g; this.b = b; this.hexColor = padZero(Integer.toHexString(r)) + padZero(Integer.toHexString(g)) + padZero(Integer.toHexString(b)); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof HexColor)) return false; return Objects.equals(getHexColor(), ((HexColor) o).getHexColor()); &#125; @Override public int hashCode() &#123; return Objects.hashCode(getHexColor()); &#125; @Override public String toString() &#123; return &quot;#&quot; + hexColor; &#125; &#125; 效果如下： 参考：https://stackoverflow.com/a/3943023/112731","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://yuhiri.me/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://yuhiri.me/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuhiri.me/tags/JavaScript/"},{"name":"Color","slug":"Color","permalink":"http://yuhiri.me/tags/Color/"}],"author":"yuhiri"},{"title":"记录关于vuepress迁移时cloudflare的Rocket Loader问题","slug":"cloudflare-display-issue","date":"2024-05-06T15:05:26.000Z","updated":"2026-01-05T13:46:38.077Z","comments":true,"path":"2024/05/06/cloudflare-display-issue/","permalink":"http://yuhiri.me/2024/05/06/cloudflare-display-issue/","excerpt":"","text":"问题描述 由于gitee的pages服务前几天挂了（原因不明，官方没什么反应），所以我只好将之前部署在gitee上的知识库迁移。 知识库是基于vuepress搭建的，迁移过程中，我将域名解析到了cloudflare上，然后使用cloudflare的CDN服务。但是，当我访问我的网站时，发现一个页面居然渲染了两次，于是每个页面都有两个重复的内容。 就像这样： |------| | 内容 | |------| |------| | 内容 | // 重复 |------| 使用F12查看源代码，发现确实是重复了两次。 存在重复的DOM结构，这是什么原因呢？ vuepress的页面都是通过js生成的，并且在没有域名解析的时候一切正常，所以我怀疑是cloudflare导致的。 之后看到一篇文章，发现了原因。 Rocket Loader is a feature by Cloudflare that can help with page load time. Unfortunately, the method in which it does this is very aggressive, is a beta product, and can often break JavaScript (including Mediavine ads). 是因为cloudflare的Rocket Loader导致的。 解决方法 Rocket Loader是cloudflare的一个js优化工具，可以延迟加载js，提高页面加载速度。 但是，由于vuepress的页面是通过js生成的，所以Rocket Loader会导致页面重复渲染。 解决方法很简单，只需要在cloudflare的设置中关闭Rocket Loader即可。 暴力直接关闭 Rocket rocker 如果 DOMContentLoaded 就在 console 加一个 warning 开启 Rocket rocker，但对特定的资源加一个 false flag: &lt;script data-cfasync=&quot;false&quot; src=&quot;/javascript.js&quot;&gt;&lt;/script&gt; 方法3是最灵活的。迁移其他的网站时，我都是使用的方法3。","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"cloudflare","slug":"cloudflare","permalink":"http://yuhiri.me/tags/cloudflare/"},{"name":"Rocket Loader","slug":"Rocket-Loader","permalink":"http://yuhiri.me/tags/Rocket-Loader/"}],"author":"yuhiri"},{"title":"关于 Tomcat 在 idea 上的中文编码问题","slug":"关于tomcat在idea上的中文编码问题","date":"2024-04-30T14:45:14.000Z","updated":"2026-01-05T13:48:19.822Z","comments":true,"path":"2024/04/30/关于tomcat在idea上的中文编码问题/","permalink":"http://yuhiri.me/2024/04/30/%E5%85%B3%E4%BA%8Etomcat%E5%9C%A8idea%E4%B8%8A%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、问题引入 在国内，无论是新手还是有一定码龄的开发人员，汉字编码问题一直都是绕不开的魔咒，本文主要对tomcat在jetbrain系列产品idea上的乱码问题提供解决经验。 二、详情描述 新手在初学Java Web时，兴致冲冲的安装了tomcat 10.x.x 或其他版本→idea新建web项目→试运行: 大段的红色乱码信息，冲击着初学者的心灵。 虽然不会实际开发造成影响，但看着这些云里雾里的信息时还是挺~影响心情的。😱 淇℃伅 --&gt; 信息 鍛戒护琛屽弬鏁帮細 --&gt; 命令行参数： 三、问题分析 在以前的 javase 学习中，中文乱码问题是通过统一编码的方式解决的（GBK和UTF-8）。 但如下图所示，很明显这次绝对不像之前那样能轻松解决。我们可以看到在idea的console下的输出出现了两种（可能不止两种）不同的流，且两种不同的流使用了两种不同的编码格式。（即白色的你好！Hello!!!可以正常显示，而红色的信息却是乱码） 这里解释一下：「你好！Hello!!!」这部分信息是我在代码里写的System.out.println(&quot;你好！Hello!!!&quot;);其他是Tomcat的输出的日志信息。 综上，问题的解决方案应该从Tomcat下手。 四、解决方案 方法一 作者在遇到这个坑的时候一开始是从问题的根本下手的，既然会出现中文乱码问题那么直接让Tomcat输出英语不就解决了吗？😸 于是就从网络上找到了解决方法； Tomcat启动时会检查本地语言环境，来调用对应的i18n文本，中文环境默认会显示中文日志，但在终端中容易出现乱码，虽然乱码问题可以通过修改字符集处理，还是想尝试一下改成英文输出。刚研究了一下，发现可以通过修改参数来设置输出日志的语言，将运行参数中的语言环境设置为英文即可，在此记录一下修改步骤 此文档所使用的环境如下 Server version name: Apache Tomcat/9.0.62 OS Name: Windows 10 JVM Version: 1.8.0_301-b09 修改catalina 修改bin/catalina.bat文件，其中有一项关于CATALINA_LOGGING_CONFIG的配置，大约是230行，不同版本所在行不一样，大致在那个区间 if not &quot;%CATALINA_LOGGING_CONFIG%&quot; == &quot;&quot; goto noJuliConfig set CATALINA_LOGGING_CONFIG=-Dnop if not exist &quot;%CATALINA_BASE%\\conf\\logging.properties&quot; goto noJuliConfig set CATALINA_LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\\conf\\logging.properties&quot; :noJuliConfig 将其中的set语句后面添加language配置-Duser.language=en -Duser.region=US，如下 set CATALINA_LOGGING_CONFIG=-Djava.util.logging.config.file=&quot;%CATALINA_BASE%\\conf\\logging.properties&quot; -Duser.language=en -Duser.region=US 注意空格。 提示：如果是在Linux系统，则修改bin/catalina.sh文件 修改时间格式 顺便改一下显示日志中的时间格式，修改conf/logging.properties，在ConsoleHandler区添加timeFormat配置 java.util.logging.ConsoleHandler.level = FINE java.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatter java.util.logging.ConsoleHandler.encoding = UTF-8 org.apache.juli.OneLineFormatter.timeFormat = yyyy-MM-dd HH:mm:ss 重启Tomcat检查修改是否生效。 作者：zhouf_cq 链接：https://www.jianshu.com/p/da8386129a50 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 不得不说，直接改成英文一定是乱码问题的通解。（直接绕开问题 但是作者一直都有一个坏毛病（X，就是喜欢把所有工具更到最新。 于是就在我的第一次更新Tomcat的时候，它又变成了中文。 Tomcat更新时，会把之前辛苦配置的文件覆盖掉，每次都要改一遍。对于我这种懒人来说，一行命令更新后，我可不想重新再修改一遍（这个不是配置文件，更新后可能会有变动不适合直接copy）。 于是，我就在idea上花费了一番功夫。 方法二 我把idea上的配置全部统一成了utf-8。 文件编码 上面是之前学javase的解决的方法。这次只要在上面的设置基础上添加一个设置。 setting→Editor→General→Console下，修改成UTF-8 Default Encoding 修改成UTF-8 OK 重启Tomcat 可以看到Tomcat日志输出正常了 五、后续问题 之前的问题这里并没有完全解决，可以看到System.out.println(&quot;你好！Hello!!!&quot;);输出的中文变成了乱码。 我们只要在idea里面配置一下项目配置就可以了。 在此处（红色的框）添加一句VM option 参数就可以了。 -Dfile.encoding=UTF-8 完美解决！ -Dfile.encoding=UTF-8这条参数很常见。 写在最后","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"yuhiri"},{"title":"转载:线段树专题-xyw813","slug":"转载-线段树专题-xyw813","date":"2024-04-07T15:58:42.000Z","updated":"2026-01-05T13:47:09.948Z","comments":true,"path":"2024/04/07/转载-线段树专题-xyw813/","permalink":"http://yuhiri.me/2024/04/07/%E8%BD%AC%E8%BD%BD-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98-xyw813/","excerpt":"","text":"本文转载自xyw813:线段树专题 前言 ඞ 本文章主要由浅入深的介绍线段树的各种操作，由于线段树特别重要。支持几乎所有的区间操作，所以笔者也会分享一些理解，同时存在难以避免的错误，还请读者指出！ 线段树的定义 线段树的定义：使用树形结构通过维护操作子节点的信息，来统计区间信息的树形结构。 为什么需要线段树 支持在时间复杂度 内完成单点（区间）修改、单点（区间）查询、区间翻转、区间最值、区间众数、区间数点等一系列区间操作，具有可拓展、灵活操作等特点。 注 : 线段树支持的操作过多，本文不会提及所有操作！ 如何实现基本的线段树 建树 建树非常简单！就是划分线段 我们将划分区间的操作称之为裂开区间 将其画成树形结构更加的形象 首先通过上图我们可以发现，其实线段树是一种堆式存储的形式 ， 我们设父节点的编号是 的话 ， 那么我们的左孩子是 , 右孩子是 (位运算不懂的，请查bing)。 其次通过上图我们发现区间只有一个数的结点，那就是叶子结点，这些叶子结点只存储值，当然我们也可以看成它是存储的区间信息(个人觉得这样更好理解)。 我们知道了存储方式，以及每个结点存储的数据，那么我们就可以建树了 递归建树 void build(int u , int l , int r){ tr[u] = {l , r , 0 , 0 }; if (l == r) return ; int mid = (l + r) &gt;&gt; 1; // 区间裂开 build(ls , l , mid); build(rs , mid + 1 , r); } 区间修改、查询 这里给出两种区间修改的方式 ， 请按照情况选择。 差分 ， 将区间操作转化为单点操作。 懒标记 , 优化未进行的操作。 差分 先介绍第一种方法，差分 ， 我们可以对原序列进行差分。 修改操作步骤 对原序列进行差分 对于区间修改只需要对 点加上 C ，再对 点减去C即可（ 注意边界） 查询 单点查询 直接求 的前缀和 , 这个操作的是时间复杂度是 区间查询 那么就需要一点技巧这里给出步骤，并附上证明 步骤 考虑维护两棵线段树 ，一棵线段树维护序列差分区间和 , 另外一棵线段树维护 求区间和只需要对使用公式 $(r + 1)\\sum_{i = 1}^{r} d_i - l\\sum_{i = 1}^{l-1} d_i - (\\sum_{i=1}^r d_i \\ i - \\sum_{i=1}^{l-1} d_i\\ i)$ 证明 区间和我们可以表示成这样 (笔者是类比树状数组求区间和的方法，可能存在错误) $$ \\sum_{i=l}^r\\sum_{j = 1}^i d_j = ( (r + 1)\\sum_{i = 1}^{r} d_i - (l - 1 + 1)\\sum_{i = 1}^{l-1} d_i ) - (\\sum_{i=1}^rd_i \\ i - \\sum_{i=1}^{l-1} d_i\\ i) $$ 核心思想：求前缀和再做差 第一种方法代码不给出，主要就是介绍思想 , 代码可以自行网络查找。如果遇到这种情况，可以借助另外一种数据结构更为方便。 懒标记 区间修改、查询 先瞅瞅懒标记tag 先好好说说 懒标记 是什么？ 用于记录历史修改操作的区间标记，大白话就是把之前没有进行的操作进行一下。 有什么用？ 用于记录历史标记，对区间进行修改时减少许多不必要的操作。 例如：我一直对区间 操作 ， 但是我只询问 , 明显 那个区间不需要修改 什么时候使用它？ 在需要对这个区间操作的时候，如果存在懒标记，那么将子节点的信息算好，懒标记再下传即可。 核心要点： 懒标记是给子节点用的！ 下传懒标记操作，实际是先通过操作父结点懒标记时算好子结点的信息，再将父结点懒标记传给子结点（这里称维护结点信息）。 这个操作往往发生在查询和修改的时候（一般会另外写一个pushdown函数） 上文指到的是加法标记，其实线段树可以维护非常多的标记。本人目前还最多接触过同时维护两种运算标记。 凡是父节点信息可以通过子结点拼凑的，都是使用线段树维护。 这是一点对线段树的理解！ 理解了懒标记，就好做区间修改和区间查询了。 区间修改 其实看到图就是怎么修改了。 先给定一个区间 [1 , 4] , 操作方式就是懒标记停在[1 , 3] , 因为我们不要用到这个区间。 [4 , 4] 这个区间操作我们其实也可以理解成停在 [4 , 4]. 注意在第二次操作的时候 , 我们对 [2 , 5] 进行操作。这时候，我们需要操作这个区间的元素 [1 , 3] , 那么在操作这个区间时 ，也就是 触 的时候 ，我们就要将懒标记下传，维护信息，然后再对对应区间进行操作（因为笔者不会如何制作动图，不然就非常的直观 , 水平菜了）。 区间查询 其实区间查询就是区间修改的阉割版，不是吗？我只需要一路将需要处理的懒标记处理了，然后发挥对应区间的信息即可。 给定一张图，来看看如何进行区间查询。 我们发现，我们将 [4 , 5] 标记维护完了，父节点和子节点的信息。 怎么维护的呢？ 一般步骤： 通过父节点懒标记维护子节点信息 将父节点的懒标记下传给子节点 将父节点的懒标记清除 请记住一点，父节点的信息一定是维护正确的，懒标记是用来给子节点用的。父节点拥有的懒标记，一定给父节点用，这一点非常重要！ 注: 懒标记本质就是未操作完的动作，被保存了下来 参考代码 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #define LL long long #define ls u &lt;&lt; 1 #define rs u &lt;&lt; 1 | 1 const int N = 100010; int n, m; LL a[N]; struct Node { int l, r; LL sum, tag; } tr[4 * N]; void pushup(Node &amp;u, const Node &amp;L, const Node &amp;R) { u.sum = L.sum + R.sum; } void puhsdown(int u) { if (tr[u].tag) { tr[ls].sum += (tr[ls].r - tr[ls].l + 1) * tr[u].tag; tr[rs].sum += (tr[rs].r - tr[rs].l + 1) * tr[u].tag; tr[ls].tag += tr[u].tag; tr[rs].tag += tr[u].tag; tr[u].tag = 0; } } void modify(int u, int l, int r, LL c) { if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) { // 修改区间信息 tr[u].sum += (tr[u].r - tr[u].l + 1) * c; // 维护结点信息 tr[u].tag += c; // 打上结点标记 return; } puhsdown(u); int mid = (tr[u].r + tr[u].l) &gt;&gt; 1; if (r &lt;= mid) modify(ls, l, r, c); else if (l &gt; mid) modify(rs, l, r, c); else { // 区间左右孩子都有 , 裂开 modify(ls, l, mid, c); modify(rs, mid + 1, r, c); } pushup(tr[u], tr[ls], tr[rs]); } LL query(int u, int l, int r) { if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; puhsdown(u); // 懒标记下传 int mid = (tr[u].l + tr[u].r) &gt;&gt; 1; LL sum = 0; if (r &lt;= mid) sum = query(ls, l, r); else if (l &gt; mid) sum = query(rs, l, r); else { sum += query(ls, l, mid); sum += query(rs, mid + 1, r); } pushup(tr[u], tr[ls], tr[rs]); return sum; } 学完可以去刷【模板】线段树 1这道题。 线段树的应用 区间最值 这个维护就比较的简单 ， 因为区间最值是通过子节点拼凑出来的信息，也就是说，[3 , 5] 的最大值是 [3 , 4 , 5] 三个结点的信息拼凑出来的，这样只需要向上 pushup 即可。 就像这样 ， 通过子节点不断向上维护即可。 学完可以去刷这道题扶苏的问题 , 这题有点毒瘤。 区间最大子段和 区间最大子段和 ，可以参照这道题小白逛公园。 即，快速求出给定区间 [l , r] 的最大子段和。 对于这题也是一个区间信息拼凑的问题。 求出最大子段和的方法 : 为什么是这样的呢？我们来分类讨论可能的情况 左边最大子段和是整个区间的最大子段和 右边最大子段和是整个区间的最大子段和 左边区间和右边区间拼接起来，组成区间最大子段和 因为我们需要考虑三种情况，所以我们的维护方式这样的。且除此之外，没有其他的情况了。 但是问题来了 ， 如何维护区间最大左子段和、区间最大右子段和？ 对于区间最大左子段和我们可以通过分类讨论，来确定 直接将左孩子的最大左子段和上传 将左孩子的整个区间和sum 和 右孩子的最大左子段和拼凑上来 对这两种情况，我们肯定要贪心的取 求出区间最大左子段和方法: 维护区间最大右子段和方法，就是类似的啦。 直接给出方法: 如何维护区间和 ，那就非常简单啦。前面已经讲过了。(如果是新手，还请扎扎实实地学，一步一步来) 参考代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #define ls u &lt;&lt; 1 #define rs (u &lt;&lt; 1 | 1) #define LL long long const int N = 500010; int n, m; int a[N]; struct node { int l, r; LL sum, lmx, rmx, mx; } tr[4 * N]; void pushup(node &amp;T, const node &amp;L, const node &amp;R) { T.sum = L.sum + R.sum; T.mx = std::max(std::max(L.mx, R.mx), L.rmx + R.lmx); T.lmx = std::max(L.lmx, L.sum + R.lmx); T.rmx = std::max(R.rmx, R.sum + L.rmx); } void build(int u, int l, int r) { tr[u] = {l, r, a[l], a[l], a[l], a[l]}; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); pushup(tr[u], tr[ls], tr[rs]); } void modify(int u, int x, LL c) { if (tr[u].l == x &amp;&amp; tr[u].r == x) { tr[u] = {x, x, c, c, c, c}; return; } int mid = (tr[u].l + tr[u].r) &gt;&gt; 1; if (x &lt;= mid) modify(ls, x, c); else modify(rs, x, c); pushup(tr[u], tr[ls], tr[rs]); } node query(int u, int l, int r) { if (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u]; int mid = (tr[u].l + tr[u].r) &gt;&gt; 1; if (r &lt;= mid) return query(ls, l, r); if (l &gt; mid) return query(rs, l, r); node T{}; pushup(T, query(ls, l, mid), query(rs, mid + 1, r)); return T; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; build(1, 1, n); while (m--) { int opt, l, r; std::cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if (opt == 1) { if (l &gt; r) std::swap(l, r); std::cout &lt;&lt; query(1, l, r).mx &lt;&lt; '\\n'; } else modify(1, l, r); } return 0; } 区间gcd 懒标记 对于gcd(a , b) 存在一些性质，比如 gcd(a , b , c) = gcd(gcd(a , b) , c) 如果你对 gcd 不了解的话，请你看我的关于gcd 和 lcm 相关结论和性质的介绍。 那么这就是区间信息的维护，需要的话加上懒标记对吧，所以比较简单。 差分维护 我们介绍另外一种，比较简单的维护方法的。 引入gcd性质 **即原序列的 gcd 也是差分的 gcd ** 这种做法的延展性也非常好，直接维护序列差分信息。 求区间和 ，这个非常好求。前面讲过，只需要维护两棵线段树即可。 区间修改，差分的区间修改，只需要进行单点修改即可. 区间gcd 查询 ，这样求出即可。 本人对于这种做法理解也不是特别深刻，建议去b站找相关视频再理解理解！ 哔哩哔哩 无法维护通过子节点维护区间信息的情况 一种做法 ：分块、莫队 另外一种可能的做法 ： 线段树 通过题目给出的一些信息也可以发现一些性质，从题设的性质出发，找到突破口。 P4145 上帝造题的七分钟 2 / 花神游历各国 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 这个题目需要发现一个性质： 题设给出数据范围最多 , 那么开方多少次就是1了呢（因为1开方不变）？ 只需要6次开方就可以到1 所以我们可以考虑直接暴力区间修改，序列中所有的数，每个数最多可以开方6次，那么意味着区间修改是常数级别的。总的时间复杂度还是 , 所以考虑直接暴力区修。 区间和， 每次区间修改之后，pushup维护区间和即可。 这里推荐董哓算法的讲解 总结 线段树，还支持其他非常多的操作，无法一一列举。原因有二 ，一是、太多操作无法一一列举，情况太多。二是 、 笔者本身实力有限，暂时无法介绍更加深入的运用。类似于zkw 线段树、区间众数，李超线段树、线段树分裂等等算法，还请读者自行了解！祝大家 RP++","categories":[{"name":"转载","slug":"转载","permalink":"http://yuhiri.me/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"线段树","slug":"线段树","permalink":"http://yuhiri.me/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}],"author":"yuhiri"},{"title":"新年快乐（2024年除夕）","slug":"新年快乐","date":"2024-02-09T08:13:09.000Z","updated":"2026-01-05T13:47:39.004Z","comments":true,"path":"2024/02/09/新年快乐/","permalink":"http://yuhiri.me/2024/02/09/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/","excerpt":"","text":"新年快乐鸭！ 今年也要努力糊马赛克砖！ヾ(≧▽≦*)o","categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"新年","slug":"新年","permalink":"http://yuhiri.me/tags/%E6%96%B0%E5%B9%B4/"}],"author":"yuhiri"},{"title":"文章推荐: C/C++环境搭建攻略","slug":"文章推荐-C-CPP-环境搭建攻略","date":"2024-01-24T10:10:48.000Z","updated":"2026-01-05T13:47:48.697Z","comments":true,"path":"2024/01/24/文章推荐-C-CPP-环境搭建攻略/","permalink":"http://yuhiri.me/2024/01/24/%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90-C-CPP-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5/","excerpt":"","text":"Link 给萌新的C/C++环境搭建攻略（VSCode和MSYS2） - Locietta的文章 - 知乎 https://zhuanlan.zhihu.com/p/401188789","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yuhiri.me/tags/C-C/"},{"name":"VSCode","slug":"VSCode","permalink":"http://yuhiri.me/tags/VSCode/"},{"name":"MSYS2","slug":"MSYS2","permalink":"http://yuhiri.me/tags/MSYS2/"},{"name":"萌新","slug":"萌新","permalink":"http://yuhiri.me/tags/%E8%90%8C%E6%96%B0/"}],"author":"yuhiri"},{"title":"__builtin__系列函数","slug":"builtin-系列函数","date":"2024-01-24T08:47:56.000Z","updated":"2026-01-05T13:47:00.572Z","comments":true,"path":"2024/01/24/builtin-系列函数/","permalink":"http://yuhiri.me/2024/01/24/builtin-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0/","excerpt":"","text":"内置函数系列：__builtin__ 在C编程中，我们经常需要进行位运算操作。为了方便处理二进制数，C提供了一组内置函数，称为__builtin__系列函数。这些函数能够高效地执行一些位运算操作，使得我们可以更方便地处理二进制数据。本篇文章将介绍一些常用的__builtin__函数。 1. __builtin_popcount(x) __builtin_popcount(x)函数用于统计一个数x的二进制表示中有多少个1。例如，对于数值x=5（二进制表示为101），__builtin_popcount(x)的返回值为2，表示二进制数中有2个1。 2. __builtin_clz(x) __builtin_clz(x)函数用于统计一个数x的二进制表示中有多少个前导0。注意，这里要计算表示符号的第一位。可以将其理解为计算前导零的个数（count leading zeroes）。例如，对于数值x=8（二进制表示为1000），__builtin_clz(x)的返回值为28，表示二进制数中有28个前导0。 3. __builtin_ctz(x) __builtin_ctz(x)函数用于统计一个数x的二进制表示中末尾有多少个0。可以将其理解为计算末尾零的个数（count trailing zeroes）。例如，对于数值x=16（二进制表示为10000），__builtin_ctz(x)的返回值为4，表示二进制数中有4个末尾0。 4. __builtin_ffs(x) __builtin_ffs(x)函数用于统计一个数x的二进制表示中最后一个1是从后往前的第几位。例如，对于数值x=10（二进制表示为1010），__builtin_ffs(x)的返回值为2，表示二进制数中最后一个1是从后往前的第2位。 5. __builtin_parity(x) __builtin_parity(x)函数用于判断一个数x的二进制表示中1的个数的奇偶性。返回值为1表示1的个数为奇数，返回值为0表示1的个数为偶数。这里的parity表示&quot;奇偶性&quot;。例如，对于数值x=6（二进制表示为110），__builtin_parity(x)的返回值为0，表示二进制数中1的个数为偶数。 需要注意的是，以上函数仅适用于int或unsigned int范围内的数值。如果超出此范围，需要在函数末尾加上&quot;ll&quot;，例如__builtin_popcount(x)应改为__builtin_popcountll(x)，在__builtin_clz(x)中也因总位数不同而答案有所不同。 另外，C++20引入了&lt;bit&gt;库，并定义了std::popcount函数，功能与__builtin_popcount相同。std::popcount函数的使用方式如下： template&lt;class T&gt; constexpr int popcount(T x) noexcept; 如果你对这些函数的复杂度感兴趣，可以参考Codeforces上关于__builtin_popcount()的复杂度证明。 Tips 在使用__builtin__系列函数时，有几个注意事项需要注意： 平台兼容性：__builtin__系列函数是GCC和Clang编译器的扩展功能，因此在使用这些函数时，需要确保编译器支持这些扩展。如果你使用的是其他编译器，这些函数可能不可用或具有不同的实现方式。 优化建议：__builtin__系列函数通常比手动实现的位运算更高效，因为编译器可以根据硬件平台和编译选项进行优化。然而，对于一些简单的位运算操作，编译器可能会自动进行优化，因此在使用__builtin__函数之前，最好进行性能测试，以确定是否真正需要使用这些函数。 参考链接： C++ Reference - std::popcount","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"__builtin__","slug":"builtin","permalink":"http://yuhiri.me/tags/builtin/"}],"author":"yuhiri"},{"title":"用 Swing 实现一个简易的动态时钟。","slug":"javaSwing-DynamicClock","date":"2023-12-13T08:46:47.000Z","updated":"2026-01-05T13:45:35.369Z","comments":true,"path":"2023/12/13/javaSwing-DynamicClock/","permalink":"http://yuhiri.me/2023/12/13/javaSwing-DynamicClock/","excerpt":"","text":"前言 本文主要介绍如何使用 Java Swing 实现一个简易的动态时钟。 开发环境 JDK 版本随意 开始 Swing 简介 Swing 是 Java 的一个 GUI 工具包，它提供了一套丰富的组件，用于开发图形用户界面（GUI）应用程序，这些组件既可用于 Java 应用程序，也可用于 Applet。 Swing 组件 JFrame 是一个顶层容器，它包含并管理其他 Swing 组件。Component 是所有 Swing 组件的超类。我们将使用 JFrame 和 JPanel 来创建一个简单的窗口。添加我们自定义的组件到 JFrame 中。 自定义的组件 ClockPanel 的实现 private static class ClockPanel extends Component &#123; private static final SimpleDateFormat DATE_FORMAT; private static final SimpleDateFormat TIME_FORMAT; static &#123; DATE_FORMAT = new SimpleDateFormat(&quot;yyyy&#x27;年&#x27;MM&#x27;月&#x27;dd&#x27;日&#x27;&quot;); TIME_FORMAT = new SimpleDateFormat(&quot;HH:mm:ss&quot;); &#125; @Override public void paint(Graphics g) &#123; super.paint(g); g.setColor(Color.BLACK); g.fillRect(0, 0, getWidth(), getHeight()); g.setColor(Color.WHITE); g.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 30)); g.drawString(DATE_FORMAT.format(Calendar.getInstance().getTime()), 20, 100); g.drawString(TIME_FORMAT.format(Calendar.getInstance().getTime()), 20, 140); &#125; &#125; 获取时间需要用到 Calender 类，再使用 SimpleDateFormat 类去对我们的日期进行自定义的格式化。 另附源码 import javax.swing.*; import java.awt.*; import java.text.SimpleDateFormat; import java.util.Calendar; /** * Package: me.yuhiri * 动态时钟 * * @Author: yuhiri * @Create: 2023/12/12 * @Version: v1.0 **/ public class DynamicClock &#123; // 标识位 private static boolean flag = true; public static void main(String[] args) &#123; JFrame frame = new JFrame(&quot;动态时钟 作者：yuhiri.me&quot;); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setMinimumSize(new Dimension(350, 230)); frame.setLocationRelativeTo(null); JPanel panel = new JPanel() &#123; @Override public void paint(Graphics g) &#123; super.paint(g); g.setColor(Color.WHITE); g.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 40)); g.drawString(&quot;当前时间：&quot;, 10, 50); &#125; &#125;; panel.setBackground(Color.BLACK); panel.setBounds(0, 0, 350, 60); frame.add(panel); ClockPanel comp = new ClockPanel(); comp.setBounds(0, 60, 350, 140); frame.add(comp); frame.setVisible(true); Thread thread = new Thread(() -&gt; &#123; while (flag) &#123; comp.repaint(); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;); frame.addWindowListener(new java.awt.event.WindowAdapter() &#123; @Override public void windowClosing(java.awt.event.WindowEvent e) &#123; // 结束线程 flag = false; try &#123; Thread.sleep(500); &#125; catch (InterruptedException ex) &#123; throw new RuntimeException(ex); &#125; thread.interrupt(); &#125; &#125;); thread.start(); while (!thread.isInterrupted()) &#123; Thread.yield(); &#125; System.out.println(&quot;exited&quot;); &#125; private static class ClockPanel extends Component &#123; private static final SimpleDateFormat DATE_FORMAT; private static final SimpleDateFormat TIME_FORMAT; static &#123; DATE_FORMAT = new SimpleDateFormat(&quot;yyyy&#x27;年&#x27;MM&#x27;月&#x27;dd&#x27;日&#x27;&quot;); TIME_FORMAT = new SimpleDateFormat(&quot;HH:mm:ss&quot;); &#125; @Override public void paint(Graphics g) &#123; super.paint(g); g.setColor(Color.BLACK); g.fillRect(0, 0, getWidth(), getHeight()); g.setColor(Color.WHITE); g.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 30)); g.drawString(DATE_FORMAT.format(Calendar.getInstance().getTime()), 20, 100); g.drawString(TIME_FORMAT.format(Calendar.getInstance().getTime()), 20, 140); &#125; &#125; &#125; 效果展示： END","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yuhiri.me/tags/Java/"},{"name":"Swing","slug":"Swing","permalink":"http://yuhiri.me/tags/Swing/"}],"author":"yuhiri"},{"title":"C/CPP，memset函数的应用","slug":"C-CPP-the-memset-function","date":"2023-11-28T15:40:05.000Z","updated":"2026-01-05T13:46:54.101Z","comments":true,"path":"2023/11/28/C-CPP-the-memset-function/","permalink":"http://yuhiri.me/2023/11/28/C-CPP-the-memset-function/","excerpt":"","text":"memset 函数的应用 函数的原型，参数和返回值 memset 函数是 C 语言的一个标准库函数，定义在&lt;string.h&gt;和memory.h头文件中（如果是 c++那么它也定义在&lt;cstring&gt;头文件中）。它的功能是将一块内存中的前 n 个字节设置为特定的值。它的原型如下： void *memset(void *str, int c, size_t n); void * __cdecl memset(void *_Dst,int _Val,size_t _Size); 参数说明： s：指向要设置的内存空间。 c：要设置的值。虽然这是一个 int 类型的值，但只有其低 8 位会被用来设置内存块，因此它通常用于设置字节值（0-255）。 n：要设置的字节数。 返回值： 返回参数s的值，即一个指向内存块的指针。 常见用法 memset 函数可以用来对任何类型的数据进行初始化，只要它们在内存中是连续存储的。下面给出一些常见的用法示例： 初始化数组：如果想要将一个数组中的所有元素都初始化为 0 或者其他某个值，可以使用 memset 函数。例如： int arr[10]; memset(arr, 0, sizeof(arr)); // 将arr数组中的10个元素都初始化为0 清空字符串：如果想要将一个字符串变量清空，即将其内容全部设置为 ‘\\0’，可以使用 memset 函数。例如： char str[20] = &quot;Hello world&quot;; memset(str, &#x27;\\0&#x27;, sizeof(str)); // 将str字符串中的20个字符都清空 设置内存块：如果想要将一块内存中的某些字节都设置为某个值，可以使用 memset 函数。例如： struct student &#123; char name[20]; int age; float score; &#125;; struct student stu; memset(&amp;stu, -1, sizeof(stu)); // 将stu结构体中的所有字节都设置为 0xff 效率和安全性 memset 函数是一个简单而高效的函数，它可以快速地对一块内存进行赋值操作。它比使用循环语句或者赋值语句逐个赋值要快得多。它也比使用 memcpy 函数或者 strcpy 函数复制一个相同值的源数据要快得多。 但是，memset 函数也有一些缺点和风险。首先，它只能对内存进行字节级别的赋值，不能对更高级别的数据类型进行赋值。例如，如果想要将一个 int 数组中的所有元素都赋值为 1，不能使用 memset(arr, 1, sizeof(arr))，因为这样会导致每个元素都变成 16,843,009(0x01010101) 。正确的做法是使用循环语句或者赋值语句逐个赋值。 其次，它不能保证对齐和字节序的一致性。不同的编译器和平台可能会有不同的对齐方式和字节序规则，这可能会影响到 memset 函数对内存赋值的结果。例如，在 小端字节序（Little Endian） 的系统中，如果想要将一个 int 变量赋值为 0x12345678，不能使用memset(&amp;x, 0x12345678, sizeof(x))，因为这样会导致 x 变成 0x78787878。正确的做法是使用直接赋值语句 x = 0x12345678。 利用 memset 函数的特性，在 OI/ACM 竞赛中我们使用 memset 函数初始化数组，使数组每个元素为一个极小值或极大值。例如： int nums[5]; memset(nums, 0x7f, sizeof(nums)); 运行结果： 2139062143 2139062143 2139062143 2139062143 2139062143 int nums[5]; memset(nums, 0x80, sizeof(nums)); 运行结果： -2139062144 -2139062144 -2139062144 -2139062144 -2139062144 可以给一个数组赋极大值和极小值，但是 char 数组不适用这个方法，char 只有 1 个字节（C/C++） memset()函数的范围为 0~0xff ，且只会对 1 个字节进行赋值，剩下的字节由上一个字节复制过来。 因此如果赋 0，会将一段内存全部置为 0，如果赋 0x7f，就会赋一个极大值；如果赋 0x80，就会赋一个为负数的极小值；如果赋 0xff，就会赋一个为-1 的值。 负数在计算机在以补码的形式存在所以 -1 的二进制为 11111111，0xff 的二进制为 11111111 附表： memset 设置的值 int 类型的值 memset 设置的值 int 类型的值 0 0 80 -2139062144 1 16843009 81 -2122219135 2 33686018 82 -2105376126 3 50529027 83 -2088533117 4 67372036 84 -2071690108 5 84215045 85 -2054847099 6 101058054 86 -2038004090 7 117901063 87 -2021161081 8 134744072 88 -2004318072 9 151587081 89 -1987475063 A 168430090 8A -1970632054 B 185273099 8B -1953789045 C 202116108 8C -1936946036 D 218959117 8D -1920103027 E 235802126 8E -1903260018 F 252645135 8F -1886417009 10 269488144 90 -1869574000 11 286331153 91 -1852730991 12 303174162 92 -1835887982 13 320017171 93 -1819044973 14 336860180 94 -1802201964 15 353703189 95 -1785358955 16 370546198 96 -1768515946 17 387389207 97 -1751672937 18 404232216 98 -1734829928 19 421075225 99 -1717986919 1A 437918234 9A -1701143910 1B 454761243 9B -1684300901 1C 471604252 9C -1667457892 1D 488447261 9D -1650614883 1E 505290270 9E -1633771874 1F 522133279 9F -1616928865 20 538976288 A0 -1600085856 21 555819297 A1 -1583242847 22 572662306 A2 -1566399838 23 589505315 A3 -1549556829 24 606348324 A4 -1532713820 25 623191333 A5 -1515870811 26 640034342 A6 -1499027802 27 656877351 A7 -1482184793 28 673720360 A8 -1465341784 29 690563369 A9 -1448498775 2A 707406378 AA -1431655766 2B 724249387 AB -1414812757 2C 741092396 AC -1397969748 2D 757935405 AD -1381126739 2E 774778414 AE -1364283730 2F 791621423 AF -1347440721 30 808464432 B0 -1330597712 31 825307441 B1 -1313754703 32 842150450 B2 -1296911694 33 858993459 B3 -1280068685 34 875836468 B4 -1263225676 35 892679477 B5 -1246382667 36 909522486 B6 -1229539658 37 926365495 B7 -1212696649 38 943208504 B8 -1195853640 39 960051513 B9 -1179010631 3A 976894522 BA -1162167622 3B 993737531 BB -1145324613 3C 1010580540 BC -1128481604 3D 1027423549 BD -1111638595 3E 1044266558 BE -1094795586 3F 1061109567 BF -1077952577 40 1077952576 C0 -1061109568 41 1094795585 C1 -1044266559 42 1111638594 C2 -1027423550 43 1128481603 C3 -1010580541 44 1145324612 C4 -993737532 45 1162167621 C5 -976894523 46 1179010630 C6 -960051514 47 1195853639 C7 -943208505 48 1212696648 C8 -926365496 49 1229539657 C9 -909522487 4A 1246382666 CA -892679478 4B 1263225675 CB -875836469 4C 1280068684 CC -858993460 4D 1296911693 CD -842150451 4E 1313754702 CE -825307442 4F 1330597711 CF -808464433 50 1347440720 D0 -791621424 51 1364283729 D1 -774778415 52 1381126738 D2 -757935406 53 1397969747 D3 -741092397 54 1414812756 D4 -724249388 55 1431655765 D5 -707406379 56 1448498774 D6 -690563370 57 1465341783 D7 -673720361 58 1482184792 D8 -656877352 59 1499027801 D9 -640034343 5A 1515870810 DA -623191334 5B 1532713819 DB -606348325 5C 1549556828 DC -589505316 5D 1566399837 DD -572662307 5E 1583242846 DE -555819298 5F 1600085855 DF -538976289 60 1616928864 E0 -522133280 61 1633771873 E1 -505290271 62 1650614882 E2 -488447262 63 1667457891 E3 -471604253 64 1684300900 E4 -454761244 65 1701143909 E5 -437918235 66 1717986918 E6 -421075226 67 1734829927 E7 -404232217 68 1751672936 E8 -387389208 69 1768515945 E9 -370546199 6A 1785358954 EA -353703190 6B 1802201963 EB -336860181 6C 1819044972 EC -320017172 6D 1835887981 ED -303174163 6E 1852730990 EE -286331154 6F 1869573999 EF -269488145 70 1886417008 F0 -252645136 71 1903260017 F1 -235802127 72 1920103026 F2 -218959118 73 1936946035 F3 -202116109 74 1953789044 F4 -185273100 75 1970632053 F5 -168430091 76 1987475062 F6 -151587082 77 2004318071 F7 -134744073 78 2021161080 F8 -117901064 79 2038004089 F9 -101058055 7A 2054847098 FA -84215046 7B 2071690107 FB -67372037 7C 2088533116 FC -50529028 7D 2105376125 FD -33686019 7E 2122219134 FE -16843010 7F 2139062143 FF -1","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"CPP","slug":"CPP","permalink":"http://yuhiri.me/tags/CPP/"}],"author":"yuhiri"},{"title":"排序算法测速","slug":"Sorting-algorithm-speed-measurement","date":"2023-10-04T06:43:46.000Z","updated":"2026-01-05T13:44:15.730Z","comments":true,"path":"2023/10/04/Sorting-algorithm-speed-measurement/","permalink":"http://yuhiri.me/2023/10/04/Sorting-algorithm-speed-measurement/","excerpt":"","text":"简介 用C语言编写，用于测试不同排序算法对数据排序的效率和速度。 程序可以测试冒泡排序、冒泡排序优化、插入排序、插入排序优化、选择排序、选择排序优化、快速排序、双轴快速排序、归并排序和希尔排序等十种排序算法，单位时间为毫秒。 程序运行时，需要确保程序根目录下存在data文件夹，且该文件夹中含有TestData.md和data.txt两个文件。若不存在该文件夹，程序将无法导出数据。 本项目对于学习和理解排序算法的实现原理，以及对不同算法在不同场景下的优劣进行了较为详细的探究和总结，适合于算法初学者和算法爱好者参考学习。 待测试的排序算法 冒泡排序 冒泡排序优化 插入排序 插入排序的二分搜索算法优化 选择排序 选择排序双轴优化 快速排序 双轴快速排序 归并排序 希尔排序 结果保存 测试数据保存到文件中 排序结果输出到控制台，并保存到文件中。 文件内容以Markdown的表格格式保存，方便后续使用。 文件名：TestData.md、data.txt 程序运行时，只有存在data的文件夹才能导出数据。 程序根目录 data - TestData.md - data.txt 测试用例 系统生成随机数 测试环境 inscode windows 11(本机) 测试源码 #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;sys/time.h&gt; #include &lt;stdint.h&gt; #define llong long long #define SIZE 100000 inline void fprintArray(int *nums, FILE *fp); inline void swap(int *a, int *b); //二分搜索 int binarySearch(int nums[], int left, int right, int target); //冒泡排序 void bubbleSort(int *nums, int size); //冒泡排序优化 void bubbleSortPlus(int *nums, int size); //插入排序 void insertSort(int *nums, int size); //插入排序的二分搜索算法优化 void insertSortPlus(int *nums, int size); //选择排序 void selectSort(int *nums, int size); //选择排序双轴优化 void selectSortPlus(int *nums, int size); // 生成随机数数组 void random_nums(int *nums); //快速排序 void quickSort(int arr[], int left, int right); //双轴快速排序 void dualPivotQuickSort(int arr[], int start, int end); //归并函数 void merge(int arr[], int left, int mid, int right); //归并排序 void mergeSort(int arr[], int left, int right); //希尔排序 void shellSort(int arr[], int size); //获取时间（毫秒级） llong getCurrentTime(); //copy Array void copyArray(int *nums, int *arr); void Backspace(const char *str); int main() &#123; llong sec1, sec2; printf(&quot;初始化中请稍后...\\n&quot;); int *nums = (int *) malloc(sizeof(int) * SIZE); //定义数组 int *array = (int *) malloc(sizeof(int) * SIZE); //定义数组 system(&quot;clear&quot;); printf(&quot;\\t\\t排序算法测试\\n\\t输入测试组数:\\t&quot;); int num; if(scanf(&quot;%d&quot;, &amp;num) == 1) &#123; printf(&quot;开始运行..\\t请稍后... \\n&quot;); &#125; else &#123; printf(&quot;异常请输入数字!\\n&quot;); exit(-1); &#125; FILE *file = fopen(&quot;./data/TestData.md&quot;, &quot;w&quot;); //排序 fprintf(file, &quot;# 排序算法测试(单位毫秒)\\n\\n&quot;); fprintf(file,&quot;| 冒泡排序 | 冒泡排序优化 | 插入排序 | 插入排序优化 | 选择排序 | 选择排序优化 | 快速排序 | 双轴快速排序 | 归并排序 | 希尔排序 |\\n&quot;); fprintf(file, &quot;|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\\n&quot;); FILE *data_num = fopen(&quot;./data/data.txt&quot;, &quot;w&quot;); for (int i = 1; i &lt;= num; ++i) &#123; char str[51]; sprintf(str,&quot;初始化第%d组数据中..&quot;,i); printf(&quot;%s&quot;,str); fflush(stdout); fprintf(file, &quot;|&quot;); random_nums(array); //生成随机数组 Backspace(str); printf(&quot;第%d组数据 (数据量: %d)\\n&quot;, i,SIZE); for (int test_count = 1; test_count &lt;= 10; ++test_count) &#123; copyArray(nums, array); //复制原始数据 switch (test_count) &#123; case 1: printf(&quot;冒泡排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); bubbleSort(nums, SIZE); sec2 = getCurrentTime(); break; case 2: printf(&quot;冒泡排序优化： &quot;); fflush(stdout); sec1 = getCurrentTime(); bubbleSortPlus(nums, SIZE); sec2 = getCurrentTime(); break; case 3: printf(&quot;插入排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); insertSort(nums, SIZE); sec2 = getCurrentTime(); break; case 4: printf(&quot;插入排序优化： &quot;); fflush(stdout); sec1 = getCurrentTime(); insertSortPlus(nums, SIZE); sec2 = getCurrentTime(); break; case 5: printf(&quot;选择排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); selectSort(nums, SIZE); sec2 = getCurrentTime(); break; case 6: printf(&quot;选择排序优化： &quot;); fflush(stdout); sec1 = getCurrentTime(); selectSortPlus(nums, SIZE); sec2 = getCurrentTime(); break; case 7: printf(&quot;快速排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); quickSort(nums, 0, SIZE - 1); sec2 = getCurrentTime(); break; case 8: printf(&quot;双轴快速排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); dualPivotQuickSort(nums, 0, SIZE - 1); sec2 = getCurrentTime(); break; case 9: printf(&quot;归并排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); mergeSort(nums, 0, SIZE - 1); sec2 = getCurrentTime(); break; case 10: printf(&quot;希尔排序： &quot;); fflush(stdout); sec1 = getCurrentTime(); shellSort(nums, SIZE); sec2 = getCurrentTime(); break; &#125; printf(&quot;%lld毫秒\\n&quot;, sec2 - sec1); fprintf(file, &quot;%lld|&quot;, sec2 - sec1); &#125; fprintf(file, &quot;\\n&quot;); fflush(file); fprintArray(array, data_num); &#125; fclose(file); fclose(data_num); free(nums); free(array); return 0; &#125; void Backspace(const char *str)&#123; system(&quot;sleep 2&quot;); for(int i = 0;i &lt; strlen(str);i++) printf(&quot;\\b&quot;); fflush(stdout); &#125; void copyArray(int *nums, int *arr) &#123; for (int i = 0; i &lt; SIZE; ++i) &#123; nums[i] = arr[i]; &#125; &#125; llong getCurrentTime() &#123; struct timeval tv; gettimeofday(&amp;tv, NULL); //该函数在sys/time.h头文件中 return tv.tv_sec * 1000 + tv.tv_usec / 1000; &#125; void shellSort(int arr[], int size) &#123; int gap, i, j, temp; for (gap = size / 2; gap &gt; 0; gap /= 2) &#123; for (i = gap; i &lt; size; i++) &#123; temp = arr[i]; for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123; arr[j] = arr[j - gap]; &#125; arr[j] = temp; &#125; &#125; &#125; void merge(int arr[], int left, int mid, int right) &#123; int n1 = mid - left + 1; int n2 = right - mid; int L[n1], R[n2]; int i, j, k; for (i = 0; i &lt; n1; i++) L[i] = arr[left + i]; for (j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j]; i = 0; j = 0; k = left; while (i &lt; n1 &amp;&amp; j &lt; n2) &#123; if (L[i] &lt;= R[j]) &#123; arr[k] = L[i]; i++; &#125; else &#123; arr[k] = R[j]; j++; &#125; k++; &#125; while (i &lt; n1) &#123; arr[k] = L[i]; i++; k++; &#125; while (j &lt; n2) &#123; arr[k] = R[j]; j++; k++; &#125; &#125; void mergeSort(int arr[], int left, int right) &#123; if (left &lt; right) &#123; int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); &#125; &#125; void quickSort(int arr[], int left, int right) &#123; if (left &gt;= right) return; int l = left, r = right; int base = arr[left]; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; arr[r] &gt;= base) --r; while (l &lt; r &amp;&amp; arr[l] &lt;= base) ++l; swap(&amp;arr[l], &amp;arr[r]); &#125; arr[left] = arr[l]; arr[l] = base; quickSort(arr, left, l - 1); quickSort(arr, l + 1, right); &#125; void dualPivotQuickSort(int arr[], int start, int end) &#123; if (start &gt;= end) return; //首先结束条件还是跟之前快速排序一样，因为不可能无限制地分下去，分到只剩一个或零个元素时该停止了 if (arr[start] &gt; arr[end]) //先把首尾两个基准进行比较，看看谁更大 swap(&amp;arr[start], &amp;arr[end]); //把大的换到后面去 int pivot1 = arr[start], pivot2 = arr[end]; //取出两个基准元素 int left = start, right = end, mid = left + 1; //因为分了三块区域，此时需要三个指针来存放 while (mid &lt; right) &#123; if (arr[mid] &lt; pivot1) //如果mid所指向的元素小于基准1，说明需要放到最左边 swap(&amp;arr[++left], &amp;arr[mid++]); //直接跟最左边交换，然后left和mid都向前移动 else if (arr[mid] &lt;= pivot2) &#123; //在如果不小于基准1但是小于基准2，说明在中间 mid++; //因为mid本身就是在中间的，所以说只需要向前缩小范围就行 &#125; else &#123; //最后就是在右边的情况了 while (arr[--right] &gt; pivot2 &amp;&amp; right &gt; mid); if (mid &gt;= right) break; swap(&amp;arr[mid], &amp;arr[right]); &#125; &#125; swap(&amp;arr[start], &amp;arr[left]); //最后基准1跟left交换位置，正好左边的全部比基准1小 swap(&amp;arr[end], &amp;arr[right]); //最后基准2跟right交换位置，正好右边的全部比基准2大 dualPivotQuickSort(arr, start, left - 1); //继续对三个区域再次进行双轴快速排序 dualPivotQuickSort(arr, left + 1, right - 1); dualPivotQuickSort(arr, right + 1, end); &#125; void selectSortPlus(int *nums, int size) &#123; int left = 0, right = size - 1; //相当于左端和右端都是已经排好序的，中间是待排序的，所以说范围不断缩小 while (left &lt; right) &#123; int min = left, max = right; for (int i = left; i &lt;= right; i++) &#123; if (nums[i] &lt; nums[min]) min = i; //同时找最小的和最大的 if (nums[i] &gt; nums[max]) max = i; &#125; swap(&amp;nums[max], &amp;nums[right]); //这里先把大的换到右边 //注意大的换到右边之后，有可能被换出来的这个就是最小的，所以说需要判断一下 //如果遍历完发现最小的就是当前右边排序的第一个元素 //此时因为已经被换出来了，所以说需要将min改到换出来的那个位置 if (min == right) min = max; swap(&amp;nums[min], &amp;nums[left]); //接着把小的换到左边 left++; //这一轮完事之后，缩小范围 right--; &#125; &#125; void selectSort(int *nums, int size) &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; int copy = i; for (int j = i + 1; j &lt; size; ++j) //挨个遍历剩余的元素，并更新 if (nums[copy] &gt; nums[j]) copy = j; int tmp = nums[i]; //找出元素之后，开始交换 nums[i] = nums[copy]; nums[copy] = tmp; &#125; &#125; void insertSortPlus(int *nums, int size) &#123; //二分搜索算法来查找对应的插入位置 for (int i = 1; i &lt; size; ++i) &#123; int tmp = nums[i]; int j = binarySearch(nums, 0, i - 1, tmp); //由二分搜索来确定插入位置 for (int k = i; k &gt; j; k--) nums[k] = nums[k - 1]; //依然是将后面的元素后移 nums[j] = tmp; &#125; &#125; void insertSort(int *nums, int size) &#123; for (int i = 1; i &lt; size; ++i) &#123; //左牌堆默认有序 int j = i, tmp = nums[i]; while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; tmp) &#123; nums[j] = nums[j - 1]; //不断进行后移操作，把位置腾出来 --j; &#125; nums[j] = tmp; &#125; &#125; void bubbleSortPlus(int *nums, int size) &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; //只需要size-1次即可 bool flag = true; //这里使用一个标记，默认为`true`表示数组是有序的 for (int j = 0; j &lt; size - i - 1; ++j) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(&amp;nums[j], &amp;nums[j + 1]); flag = false; //如果发生交换，说明不是有序的，把标记变成`false` &#125; &#125; if (flag) break;//如果没有发生任何交换，flag一定是`true`，数组已经有序，所以说直接退出 &#125; &#125; void bubbleSort(int *nums, int size) &#123; for (int i = 0; i &lt; size; ++i) &#123; for (int j = 0; j &lt; size - i - 1; ++j) &#123; if (nums[j] &gt; nums[j + 1]) swap(&amp;nums[j], &amp;nums[j + 1]); &#125; &#125; &#125; int binarySearch(int nums[], int left, int right, int target) &#123; int mid; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (target == nums[mid]) return mid + 1; //如果插入元素跟中间元素相等，直接返回后一位 else if (target &lt; nums[mid]) &#123; right = mid - 1; //范围划到左边 &#125; else left = mid + 1; //范围划到右边 &#125; return left; //不断划分范围，left也就是待插入位置了 &#125; inline void swap(int *a, int *b) &#123; int tmp = *a; *a = *b; *b = tmp; &#125; inline void fprintArray(int *nums, FILE *fp) &#123; for (int i = 0; i &lt; SIZE; ++i) &#123; fprintf(fp, &quot;%d,&quot;, nums[i]); &#125; fputc(&#x27;\\n&#x27;, fp); fflush(fp); &#125; void random_nums(int *nums) &#123; // 设置种子，保证每次运行程序生成的随机数都不同 srand(time(NULL) + rand()); for (int i = 0; i &lt; SIZE; i++) &#123; nums[i] = rand(); &#125; &#125; Makefile all: main CC = clang override CFLAGS += -g -Wno-everything -pthread -lm SRCS = $(shell find . -name &#x27;.ccls-cache&#x27; -type d -prune -o -type f -name &#x27;*.c&#x27; -print) HEADERS = $(shell find . -name &#x27;.ccls-cache&#x27; -type d -prune -o -type f -name &#x27;*.h&#x27; -print) main: $(SRCS) $(HEADERS) $(CC) $(CFLAGS) $(SRCS) -o &quot;$@&quot; main-debug: $(SRCS) $(HEADERS) $(CC) $(CFLAGS) -O0 $(SRCS) -o &quot;$@&quot; clean: rm -f main main-debug 测试结果 杂项 inscode在线运行 地址：https://inscode.csdn.net/@stazxr/C-Sorting-algorithm-test 源码克隆：https://gitcode.net/m0_44950849/C.git","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"author":"yuhiri"},{"title":"开源免费、开箱即用的中后台管理模版：vue-pure-admin","slug":"vue-pure-admin","date":"2023-09-14T13:55:32.000Z","updated":"2026-01-05T13:43:16.938Z","comments":true,"path":"2023/09/14/vue-pure-admin/","permalink":"http://yuhiri.me/2023/09/14/vue-pure-admin/","excerpt":"","text":"大家好，我是TJ 之前陆陆续续给大家推荐过很多后台管理模版了，但是模版这东西永远不嫌多，所以，今天再添一枚：vue-pure-admin vue-pure-admin采用了当下最为流线的技术栈，其中主要包括： Vue3 Vite Element-Plus TypeScript Pinia Tailwindcss 很多热门模版一般功能都特别强大，这也导致了内容非常多，但实际很多时候我们就只要一个主体内容就可以。所以，这里值得注意的是，vue-pure-admin还提供了一个精简版本，更适合直接引入到项目作为开发初始版本。 vue-pure-admin提供的精简版打包后全局引入（包含Element-Plus的情况下）才2.3MB的大小，再利用brotli压缩之后，甚至低于350kb，可谓是极致精简了！ 该模版还贴心的提供了教程视频，简直是保姆级模版了，实属难得： 开发教程：https://www.bilibili.com/video/BV1kg411v7QT UI设计：https://www.bilibili.com/video/BV17g411T7rq 接下来一起欣赏下vue-pure-admin的效果吧： 登录界面 Dashboard 流程图组件 表单设计组件 文本编辑器组件 PPT在线操作组件 这里就简单预览一下，其实还有更多有意思的组件展示，留给大家自己去探索吧！最后，奉上相关地址，喜欢的直接冲吧！ 体验地址：https://yiming_chang.gitee.io/vue-pure-admin 开源地址：https://github.com/pure-admin/vue-pure-admin 欢迎扫描下方二维码，关注公众号：TJ君，订阅每日推荐，获取更多好用效率工具！ 本文由 TJ君 创作 原文地址：https://blog.didispace.com/tj-opensource-vue-pure-admin/ 版权声明：自由转载-非商用-非衍生-保持署名 (CC BY-NC-ND 3.0) 原创不易，转载请注明出处，感谢支持！如果本文对您有用，欢迎转发分享！","categories":[{"name":"转载","slug":"转载","permalink":"http://yuhiri.me/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yuhiri.me/tags/vue/"}],"author":"yuhiri"},{"title":"javase学习文档","slug":"javase-note","date":"2023-08-01T08:00:28.000Z","updated":"2026-01-05T13:45:49.195Z","comments":true,"path":"2023/08/01/javase-note/","permalink":"http://yuhiri.me/2023/08/01/javase-note/","excerpt":"","text":"javase学习文档（更新） javase 学习文档已更新 查看地址：https://lib.yuhiri.me/codenotes/java/javase/","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yuhiri.me/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"http://yuhiri.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Note","slug":"Note","permalink":"http://yuhiri.me/tags/Note/"}],"author":"yuhiri"},{"title":"力扣1401. 圆和矩形是否有重叠","slug":"力扣1401-圆和矩形是否有重叠","date":"2023-06-25T08:34:23.000Z","updated":"2026-01-05T13:48:10.577Z","comments":true,"path":"2023/06/25/力扣1401-圆和矩形是否有重叠/","permalink":"http://yuhiri.me/2023/06/25/%E5%8A%9B%E6%89%A31401-%E5%9C%86%E5%92%8C%E7%9F%A9%E5%BD%A2%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%8F%A0/","excerpt":"","text":"题目描述 题目地址：https://leetcode.cn/problems/circle-and-rectangle-overlapping/ 给你一个以 (radius, xCenter, yCenter) 表示的圆和一个与坐标轴平行的矩形 (x1, y1, x2, y2) ，其中 (x1, y1) 是矩形左下角的坐标，而 (x2, y2) 是右上角的坐标。 如果圆和矩形有重叠的部分，请你返回 true ，否则返回 false 。 换句话说，请你检测是否 存在 点 ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。 示例 1 ： 输入：radius = 1, xCenter = 0, yCenter = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1 输出：true 解释：圆和矩形存在公共点 (1,0) 。 示例 2 ： 输入：radius = 1, xCenter = 1, yCenter = 1, x1 = 1, y1 = -3, x2 = 2, y2 = -1 输出：false 示例 3 ： 输入：radius = 1, xCenter = 0, yCenter = 0, x1 = -1, y1 = 0, x2 = 0, y2 = 1 输出：true 提示： 解答 方法一：分区域讨论 思路 在思考这个问题之前，我们先考虑一种临界情况：什么时候圆和矩形只有一个公共点呢？有两种情况： 圆「贴」在矩形的四周 圆「顶」在矩形的顶点 设圆心的坐标为 ，圆的半径为 , 矩形的左下端点为 ，右上端点为 ，形式化地，这两种情况可以继续细分： 圆「贴」在矩形的四周 圆「顶」在矩形的顶点 由此可见，圆心临界位置的轨迹是一个「圆角矩形」——如果我们尝试把圆心向「圆角矩形」内部移动，就一定会出现公共点；如果向「圆角矩形」外部移动，就不会出现公共点。那么问题就转化成了判断圆心是否在这个圆角矩形内，如果在就表示有公共点，否则没有公共点。 对于这个圆角矩形我们可以分成九个部分来讨论： 圆心在中心矩形中： 圆心在上部矩形中： 圆心在下部矩形中： 圆心在左部矩形中： 圆心在右部矩形中： 圆心在左下方圆角中： 圆心在右下方圆角中： 圆心在左上方圆角中： 圆心在右上方圆角中： 对于上述情况我们分别进行讨论，由于在判断圆角的情况时，已经判断过五种矩形内的情况，所以不需要再分别讨论横坐标和纵坐标的取值范围，直接判断圆心到顶点的距离即可。 代码如下 C++ class Solution { public: long long distance(int ux, int uy, int vx, int vy) { return (long long)pow(ux - vx, 2) + (long long)pow(uy - vy, 2); } bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) { /* 圆心在矩形内部 */ if (x1 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 &amp;&amp; y1 &lt;= yCenter &amp;&amp; yCenter &lt;= y2) { return true; } /* 圆心在矩形上部*/ if (x1 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 &amp;&amp; y2 &lt;= yCenter &amp;&amp; yCenter &lt;= y2 + radius) { return true; } /* 圆心在矩形下部*/ if (x1 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 &amp;&amp; y1 - radius &lt;= yCenter &amp;&amp; yCenter &lt;= y1) { return true; } /* 圆心在矩形左部*/ if (x1 - radius &lt;= xCenter &amp;&amp; xCenter &lt;= x1 &amp;&amp; y1 &lt;= yCenter &amp;&amp; yCenter &lt;= y2) { return true; } /* 圆心在矩形右部*/ if (x2 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 + radius &amp;&amp; y1 &lt;= yCenter &amp;&amp; yCenter &lt;= y2) { return true; } /* 矩形左上角 */ if (distance(xCenter, yCenter, x1, y2) &lt;= radius * radius) { return true; } /* 矩形左下角 */ if (distance(xCenter, yCenter, x1, y1) &lt;= radius * radius) { return true; } /* 矩形右上角 */ if (distance(xCenter, yCenter, x2, y2) &lt;= radius * radius) { return true; } /* 矩形右下角 */ if (distance(xCenter, yCenter, x1, y2) &lt;= radius * radius) { return true; } /* 无交点 */ return false; } }; C语言 long long distance(int ux, int uy, int vx, int vy) { return (long long)pow(ux - vx, 2) + (long long)pow(uy - vy, 2); } bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) { /* 圆心在矩形内部 */ if (x1 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 &amp;&amp; y1 &lt;= yCenter &amp;&amp; yCenter &lt;= y2) { return true; } /* 圆心在矩形上部 */ if (x1 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 &amp;&amp; y2 &lt;= yCenter &amp;&amp; yCenter &lt;= y2 + radius) { return true; } /* 圆心在矩形下部 */ if (x1 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 &amp;&amp; y1 - radius &lt;= yCenter &amp;&amp; yCenter &lt;= y1) { return true; } /* 圆心在矩形左部 */ if (x1 - radius &lt;= xCenter &amp;&amp; xCenter &lt;= x1 &amp;&amp; y1 &lt;= yCenter &amp;&amp; yCenter &lt;= y2) { return true; } /* 圆心在矩形右部 */ if (x2 &lt;= xCenter &amp;&amp; xCenter &lt;= x2 + radius &amp;&amp; y1 &lt;= yCenter &amp;&amp; yCenter &lt;= y2) { return true; } /* 矩形左上角 */ if (distance(xCenter, yCenter, x1, y2) &lt;= radius * radius) { return true; } /* 矩形左下角 */ if (distance(xCenter, yCenter, x1, y1) &lt;= radius * radius) { return true; } /* 矩形右上角 */ if (distance(xCenter, yCenter, x2, y2) &lt;= radius * radius) { return true; } /* 矩形右下角 */ if (distance(xCenter, yCenter, x1, y2) &lt;= radius * radius) { return true; } /* 无交点 */ return false; } 复杂度 时间复杂度：。 空间复杂度：。 方法二：求圆心到矩形区域的最短距离 思路 在求圆和直线的位置关系时，我们常常会计算圆心到直线的垂直线段的距离。这条垂直线段的距离小于半径的时候，就说明两者相交。更进一步地考虑，其实是因为这条垂直线段的长度已经是圆心到直线上任意点中最小的了，如果最小的线段长度比圆半径小，说明存在点在圆内。 我们可以类比这个思想，来计算求圆心到矩形区域的最短距离。 我们可以分解成两个问题，即圆心到区域 的最小值 ，和圆心到区域 的最小值 ，我们可以得到这样的关系： 圆心到矩形区域的最小距离就是 。未了方便理解，我们可以把平面区域根据 、、、 四条直线分割成九个区域，分类讨论就可以合并到这个结果。 得到这个距离之后，我们再和半径比较，如果这个距离不大于半径的话，就说明存在公共点。 代码如下 C++ class Solution { public: bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) { long long dist = 0; if (xCenter &lt; x1 || xCenter &gt; x2) { dist += min(pow(x1 - xCenter, 2), pow(x2 - xCenter, 2)); } if (yCenter &lt; y1 || yCenter &gt; y2) { dist += min(pow(y1 - yCenter, 2), pow(y2 - yCenter, 2)); } return dist &lt;= radius * radius; } }; C语言 static double min(double a, double b) { return a &lt; b ? a : b; } bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) { double dist = 0; if (xCenter &lt; x1 || xCenter &gt; x2) { dist += min(pow(x1 - xCenter, 2), pow(x2 - xCenter, 2)); } if (yCenter &lt; y1 || yCenter &gt; y2) { dist += min(pow(y1 - yCenter, 2), pow(y2 - yCenter, 2)); } return dist &lt;= radius * radius; } 复杂度 时间复杂度：。 空间复杂度：。 作者：LeetCode-Solution 链接：https://leetcode.cn/problems/circle-and-rectangle-overlapping/solution/yuan-he-ju-xing-shi-fou-you-zhong-die-by-zlbk/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"转载","slug":"转载","permalink":"http://yuhiri.me/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yuhiri.me/tags/LeetCode/"},{"name":"C","slug":"C","permalink":"http://yuhiri.me/tags/C/"}],"author":"yuhiri"},{"title":"闲着没事干","slug":"闲着没事干","date":"2023-06-14T13:12:10.000Z","updated":"2026-01-05T13:47:43.941Z","comments":true,"path":"2023/06/14/闲着没事干/","permalink":"http://yuhiri.me/2023/06/14/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E5%B9%B2/","excerpt":"","text":"就丢这里了 语言 C、C++、Java、Python、Go、MATLAB、C#、dotNet、®、Lisp、Scheme、(Perl)、(julia)、(Ruby)、Rust、Lua、LuaJIT、(kotlin)、(Swift) 前端 HTML、CSS、JavaScript、SCSS、TypeScript、vue、vite、(PHP) 工具 git、node、docker、conda、Anaconda、jupyter、adb、cmake、gdb、clang、LLVM、lldb、xmake、make、MSVC、tig、(Mercurial)、Ruff 包管理器 UV、npm、pnpm、yarn、pip、scoop、winget、pacman、wget、apt、maven、yum… 数据库 MySQL、SQL Server、Redis、(MongoDB)、(Oracle) Coding VScode、Clion、IDEA、pycharm、neovim、vim、sublime、(Emacs)、nano、visual studio OS Windows11、Archlinux、kali、Ubuntu、wsl 文档 Markdown、LaTex、typora、Notion、obsidian、vuepress、Hexo、WordPress、vitepress Other GNU、7zip、pandoc、picgo、starship、utools、everything、oh-my-posh、NSSM Game unity、UE4、UE5、(Blender)、(Godot)… *注：加括号表示仅了解，并未接触过","categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"划水","slug":"划水","permalink":"http://yuhiri.me/tags/%E5%88%92%E6%B0%B4/"}],"author":"yuhiri"},{"title":"C语言基础排序(demo)","slug":"C语言基础排序-demo","date":"2023-05-15T07:57:55.000Z","updated":"2026-01-05T13:46:49.276Z","comments":true,"path":"2023/05/15/C语言基础排序-demo/","permalink":"http://yuhiri.me/2023/05/15/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F-demo/","excerpt":"","text":"今日份的丧心病狂 基础排序 冒泡、插入、选择（157行警告🤤） 🤔 #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; #define _comp_ comp(int a, int b) int comp1(int a, int b) &#123; //升序 return a - b; &#125; int comp2(int a, int b) &#123; //降序 return b - a; &#125; void printArray(int *nums, int size); void swap(int *a, int *b); //二分搜索 int binarySearch(int nums[], int left, int right, int target, int _comp_); //冒泡排序 void bubbleSort(int *nums, int size, int _comp_); //冒泡排序优化 void bubbleSortPlus(int *nums, int size, int _comp_); //插入排序 void insertSort(int *nums, int size, int _comp_); //插入排序的二分搜索算法优化 void insertSortPlus(int *nums, int size, int _comp_); //选择排序 void selectSort(int *nums, int size, int _comp_); //选择排序双轴优化 void selectSortPlus(int *nums, int size, int _comp_); int main() &#123; int test[10] = &#123;9, 6, 5, 45, 3, 2, 1, 0, 7, 8&#125;; printArray(test, 10); bubbleSort(test, 10, comp2); //冒泡排序 printArray(test, 10); bubbleSortPlus(test, 10, comp1); //冒泡排序优化 printArray(test, 10); insertSort(test, 10, comp2); //插入排序 printArray(test, 10); insertSortPlus(test, 10, comp1); //插入排序二分搜索算法优化 printArray(test, 10); selectSort(test, 10, comp2); //选择排序 printArray(test, 10); selectSortPlus(test, 10, comp1); //选择排序双轴优化 printArray(test, 10); return 0; &#125; void selectSortPlus(int *nums, int size, int _comp_) &#123; int left = 0, right = size - 1; //相当于左端和右端都是已经排好序的，中间是待排序的，所以说范围不断缩小 while (left &lt; right) &#123; int min = left, max = right; for (int i = left; i &lt;= right; i++) &#123; if (nums[i] &lt; nums[min]) min = i; //同时找最小的和最大的 if (nums[i] &gt; nums[max]) max = i; &#125; if (comp(1, 2) &gt; 0) &#123; swap(&amp;nums[max], &amp;nums[left]); if (min == left) min = max; swap(&amp;nums[min], &amp;nums[right]); &#125; else &#123; swap(&amp;nums[max], &amp;nums[right]); //这里先把大的换到右边 //注意大的换到右边之后，有可能被换出来的这个就是最小的，所以说需要判断一下 //如果遍历完发现最小的就是当前右边排序的第一个元素 //此时因为已经被换出来了，所以说需要将min改到换出来的那个位置 if (min == right) min = max; swap(&amp;nums[min], &amp;nums[left]); //接着把小的换到左边 &#125; left++; //这一轮完事之后，缩小范围 right--; &#125; &#125; void selectSort(int *nums, int size, int _comp_) &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; //因为最后一个元素一定是在对应位置上的，所以只需要进行N - 1轮排序 int copy = i; for (int j = i + 1; j &lt; size; ++j) //挨个遍历剩余的元素，并更新 if (comp(nums[copy], nums[j]) &gt; 0) copy = j; int tmp = nums[i]; //找出元素之后，开始交换 nums[i] = nums[copy]; nums[copy] = tmp; &#125; &#125; void insertSortPlus(int *nums, int size, int _comp_) &#123; //二分搜索算法来查找对应的插入位置 for (int i = 1; i &lt; size; ++i) &#123; int tmp = nums[i]; int j = binarySearch(nums, 0, i - 1, tmp, comp); //由二分搜索来确定插入位置 for (int k = i; k &gt; j; k--) nums[k] = nums[k - 1]; //依然是将后面的元素后移 nums[j] = tmp; &#125; &#125; void insertSort(int *nums, int size, int _comp_) &#123; for (int i = 1; i &lt; size; ++i) &#123; //左牌堆默认有序 int j = i, tmp = nums[i]; while (j &gt; 0 &amp;&amp; comp(nums[j - 1], tmp) &gt; 0) &#123; nums[j] = nums[j - 1]; //不断进行后移操作，把位置腾出来 --j; &#125; nums[j] = tmp; &#125; &#125; void bubbleSortPlus(int *nums, int size, int _comp_) &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; //只需要size-1次即可 bool flag = true; //这里使用一个标记，默认为`true`表示数组是有序的 for (int j = 0; j &lt; size - i - 1; ++j) &#123; if (comp(nums[j], nums[j + 1]) &gt; 0) &#123; swap(&amp;nums[j], &amp;nums[j + 1]); flag = false; //如果发生交换，说明不是有序的，把标记变成`false` &#125; &#125; if (flag) break;//如果没有发生任何交换，flag一定是`true`，数组已经有序，所以说直接退出 &#125; &#125; void bubbleSort(int *nums, int size, int _comp_) &#123; for (int i = 0; i &lt; size; ++i) &#123; for (int j = 0; j &lt; size - i - 1; ++j) &#123; if (comp(nums[j], nums[j + 1]) &gt; 0) swap(&amp;nums[j], &amp;nums[j + 1]); &#125; &#125; &#125; int binarySearch(int nums[], int left, int right, int target, int _comp_) &#123; int mid; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (target == nums[mid]) return mid + 1; //如果插入元素跟中间元素相等，直接返回后一位 else if (comp(target, nums[mid]) &lt; 0) &#123; right = mid - 1; //范围划到左边 &#125; else left = mid + 1; //范围划到右边 &#125; return left; //不断划分范围，left也就是待插入位置了 &#125; void swap(int *a, int *b) &#123; int tmp = *a; *a = *b; *b = tmp; &#125; void printArray(int *nums, int size) &#123; for (int i = 0; i &lt; size; ++i) &#123; printf(&quot;%d &quot;, nums[i]); &#125; putchar(&#x27;\\n&#x27;); &#125; output: 9 6 5 45 3 2 1 0 7 8 45 9 8 7 6 5 3 2 1 0 0 1 2 3 5 6 7 8 9 45 45 9 8 7 6 5 3 2 1 0 0 1 2 3 5 6 7 8 9 45 45 9 8 7 6 5 3 2 1 0 0 1 2 3 5 6 7 8 9 45","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"author":"yuhiri"},{"title":"Windows系统安装使用Scoop包管理器","slug":"Windows系统安装使用Scoop包管理器","date":"2023-05-12T10:24:59.000Z","updated":"2026-01-05T13:42:42.096Z","comments":true,"path":"2023/05/12/Windows系统安装使用Scoop包管理器/","permalink":"http://yuhiri.me/2023/05/12/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Scoop%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","excerpt":"","text":"前言 Scoop是Windows的命令行安装程序。 如果用过Linux系统，使用apt-get工具安装过软件，或者用过Python，知道pip工具用于管理Python各种依赖包，那么理解Scoop就比较容易，这些工具的设计理念与使用方法都非常类似。 Scoop一般用来管理绿色软件，即是一种通过解压压缩包即可就地使用的软件，对于比较专业软件（比如Office、Adobe等）支持不好 基础环境配置 在准备安装之前，建议进行配置（如果你能解决GitHub访问问题，请跳过😄） 如果你是win10系统，建议安装Terminal（win11已经自带，请跳转至正式开始Scoop的安装） 新一代终端Windows Terminal 支持标签页、多种命令行工具多开… 可定制美化 Terminal 终端 安装 Terminal 打开Windows自带的应用商店（MicroSoft Store） 搜索Terminal 安装 建议添加任务栏方便使用 Terminal 使用 首次运行时，Windows Terminal以Powershell作为默认配置文件启动。下拉菜单可用于启动其他选项卡并访问设置： 可以在设置里面进行修改透明度，更改背景等设置 我的个人效果如下： 更多使用技巧请点击访问官方文档 正常访问 GitHub 由于GitHub在国内时常会被DNS劫持，所以需要进行本地反代理，保证访问GitHub稳定。 本文推荐使用Steam++来完成本地反代。 安装： 打开Windows自带的Microsoft Store. 搜索Watt Toolkit并安装. 然后，给GitHub打上勾点一键加速. 打开GitHub链接看看是否能访问：https://github.com 正式开始Scoop的安装 github地址：https://github.com/ScoopInstaller/Scoop 文档地址：https://scoop.sh/ 命令安装 为了让PowerShell可以执行脚本，首先需要设置PowerShell执行策略，通过输入以下命令Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser（在之前安装好的Terminal执行） 从非管理员 PowerShell 运行此命令以使用默认配置安装 scoop， Scoop将安装到 C:\\Users&lt;YOUR USERNAME&gt;\\scoop irm get.scoop.sh | iex # 使用镜像安装 irm get.scoop.sh -Proxy &#x27;http://&lt;ip:port&gt;&#x27; | iex 或者以下命令： Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;) 高级安装 如果你不想安装到C盘，可采用此方法（小白不推荐） 先执行 irm get.scoop.sh -outfile &#x27;install.ps1&#x27; 下载安装程序 可以explorer .在当前打开资源管理器，查看下载的文件 查看安装程序的所有可配置参数。 .\\install.ps1 -? 例如，可以将 scoop 安装到自定义目录，配置 scoop 进行安装全局程序到自定义目录，并在安装过程中绕过系统代理。 .\\install.ps1 -ScoopDir &#x27;D:\\Applications\\Scoop&#x27; -ScoopGlobalDir &#x27;F:\\GlobalScoopApps&#x27; -NoProxy 或者，可以使用旧方法通过设置环境变量来配置自定义目录。（不推荐） $env:SCOOP=&#x27;D:\\Applications\\Scoop&#x27; $env:SCOOP_GLOBAL=&#x27;F:\\GlobalScoopApps&#x27; [Environment]::SetEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;, $env:SCOOP_GLOBAL, &#x27;Machine&#x27;) irm get.scoop.sh | iex 默认情况下已禁用管理员控制台下Scoop的安装，如果需要使用 -RunAsAdmin irm get.scoop.sh -outfile &#x27;install.ps1&#x27; .\\install.ps1 -RunAsAdmin [-OtherParameters ...] # I don&#x27;t care about other parameters and want a one-line command iex &quot;&amp; &#123;$(irm get.scoop.sh)&#125; -RunAsAdmin&quot; Scoop配置 如果输出了successfully，就代表已成功安装Scoop。 打开C:\\Users\\&lt;user name&gt;\\scoop路径就可以看到下面的文件夹 app —— 安装的软件放在这里 bucket —— 已经添加的软件仓库 shims —— Scoop可以自动生成shell脚本，省去了Windows配环境变量的烦恼（我的jdk，MG-win64，cmake，python，conda，git等环境变量基本就靠Scoop的shims） 我们先在Terminal中输入scoop -v看看scoop命令是否可以使用 可以看到我这边可以正常显示版本号 输入scoop help就可以看Scoop命令 部分命令: Command Summary update 更新 list 显示已安装列表 install 安装 uninstall 卸载 search 搜索app status 检查更新 bucket Scoop buckets cache 缓存 reset 重设 cleanup 清除旧版 help 帮助 shim shims 安装apps 由于Scoop的软件仓库，是基于Git和7zip工具管理的，所以我们首先需要安装的就是git。 scoop install git git config --global http.sslVerifyfalse # git 配置 注意：安装时会自动安装7zip。安装会很慢…等 好吧，其实可以先安装aria2多线程加速(笑 scoop install aria2 如果使用代理，有时需要通过如下命令关闭 aria2 scoop config aria2-enabled false scoop update # 更新一下Scoop scoop全局安装软件可以附加`-g`,如：scoop install git -g;但是必须以管理员的身份执行。 bucket 在 Scoop 中，存储桶是应用程序的集合。或者，更具体地说，存储桶是一个 Git 存储库，其中包含描述如何安装应用程序的 JSON 应用程序清单。 Scoop默认的bucket是main scoop bucket known # 查看社区的bucket列表 我们可以为main bucket配置镜像来加速 先卸载 main的bucket scoop bucket rm main 添加 main 镜像代理 scoop bucket add main https://mirror.ghproxy.com/github.com/ScoopInstaller/Main.git 添加其他 bucket 常用bucket：https://rasa.github.io/scoop-directory/by-score.html scoop bucket add extras # 添加了多种软件包 scoop bucket add versions # 保留了旧版本 scoop bucket add dorado https://github.com/chawyehsu/dorado # 许多国内应用qq、微信 国内推荐： scoop bucket add scoop-cn https://mirror.ghproxy.com/github.com/duzyn/scoop-cn 指定仓库安装 scoop install &lt;bucket_Name&gt;/&lt;packName&gt; jdk安装实例演示 先添加Java的bucket scoop bucket add java 再使用scoop search来搜索jdk的包 scoop search jdk 选择自己需要的jdk版本，以下以oraclejdk-lts做演示 scoop install oraclejdk-lts 安装成功！ 安装后scoop会保留安装包，可以使用scoop cache show查看缓存。 scoop cache rm * # 清除所有缓存 scoop 版本控制 scoop可以使用scoop reset切换软件版本,用法是scoop reset &lt;pack name&gt;@&lt;version number&gt;、scoop reset &lt;对应的软件包名&gt; scoop install &lt;pack name&gt;@&lt;version number&gt;安装指定的版本（这个不太好用） scoop cleanup用来清理旧版本 scoop cleanup * # 清理所有旧版 软件推荐 #调用管理员权限 scoop install sudo #使用 sudo scoop install git -g #scoop 本地搜索，提高搜索效率 scoop install scoop-search scoop-search jdk #插件补全 scoop install scoop-completion 我的安装列表 adb 35.0.2 age 1.2.0 alist 3.39.1 aria2 1.37.0-1 dark 3.14 dotnet-sdk-lts 8.0.404 fastfetch 2.28.0 go 1.23.3 innounp 1.76 lua 5.4.7-2 maven 3.9.9 msys2 2024-07-27 neovim 0.10.2 nodejs-lts 22.11.0 oraclejdk-lts 21.0.4 python 3.13.0 rustup-gnu 1.27.1 scoop-completion 0.3.0 scoop-search 1.5.0 sudo 0.2020.01.26 visualvm 2.1.10 zulufx17-jdk 17.54.21 7zip 24.08 everything 1.4.1.1026 git 2.47.0.2 JetBrainsMono-NF 3.2.1 NerdFontsSymbolsOnly 3.2.1 pandoc 3.5 picgo 2.3.1 qbittorrent-enhanced 5.0.0.10 snipaste-beta 2.9.2-Beta starship 1.21.1 附录 常用命令 # 查看已安装程序 scoop list # 查看更新 scoop status # 更新版本，更新仓库 scoop update # 删除旧版本 scoop cleanup # 自身诊断 scoop checkup Aria2 的参数 scoop config aria2-retry-wait 4 scoop config aria2-split 16 scoop config aria2-max-connection-per-server 16 scoop config aria2-min-split-size 4M Scoop代理 #设置代理 scoop config proxy 127.0.0.1:7890 #关闭代理 scoop config proxy false # 2024年4月19日更新 false不在支持 请使用none #使用用户代理 scoop config proxy currentuser@default #绕过代理直连 scoop config proxy none 2024/11/25更新 最近把Windows11升级到了24H2，24H2系统自带了sudo所以就把scoop安装的sudo卸载掉了。 下面教你如何启用24H2的 sudo 首先你应该先升级到24H2 然后转到设置-&gt;系统-&gt;开发人员选项 保证开发人员模式是打开的，然后打开启用sudo开关 以管理员身份打开powershell或者cmd，执行sudo config --enable normal命令 sudo config --enable normal sudo config --enable 启用模式 模式可选：forceNewWindow、disableInput、normal，“在新窗口中”、“禁用输入”、“内联”模式。 比如内联模式，就和linux终端一样。 sudo config --enable normal 关于sudo：https://github.com/microsoft/sudo ps: fastfetch好好玩","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yuhiri.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"包管理器","slug":"包管理器","permalink":"http://yuhiri.me/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"Scoop","slug":"Scoop","permalink":"http://yuhiri.me/tags/Scoop/"},{"name":"软件","slug":"软件","permalink":"http://yuhiri.me/tags/%E8%BD%AF%E4%BB%B6/"}],"author":"yuhiri"},{"title":"用C语言实现字符串全排列","slug":"用C语言实现字符串全排列","date":"2023-04-10T05:03:30.000Z","updated":"2026-01-05T13:47:31.834Z","comments":true,"path":"2023/04/10/用C语言实现字符串全排列/","permalink":"http://yuhiri.me/2023/04/10/%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"用 C 语言实现字符串全排列 字符串全排列是指给定一个字符串，输出它的所有可能的排列方式 例如，给定字符串&quot;abc&quot;，全排列有&quot;abc&quot;，“acb”，“bac”，“bca”，“cab”，“cba” 一种常用的方法是使用递归和回溯的思想 首先，我们定义一个 swap 函数，用来交换两个字符的位置 然后，我们定义一个 permutation 函数，用来递归生成全排列 permutation 函数接受三个参数：str 是要排列的字符串，start 是当前处理的位置，end 是字符串的最后一个位置 permutation 函数的基本思路是： 如果 start 等于 end，说明只有一个字符，直接输出 str 否则，从 start 到 end 遍历每个位置 i，将 str[start]和 str[i]交换，然后递归处理 start+1 到 end 的位置 递归返回后，再将 str[start]和 str[i]交换回来，恢复原来的顺序，这叫做回溯 这样就可以保证每个位置都被不同的字符填充过一次，生成所有可能的排列 最后，在 main 函数中，我们输入一个字符串，并调用 permutation 函数生成全排列 下面是完整的代码和运行结果： 使用标准库函数&lt;string.h&gt;中的strdup函数来复制一个字符串 // 用C语言实现字符串全排列 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; //定义一个swap函数，使用指针参数 void swap(char *a, char *b) &#123; char temp = *a; *a = *b; *b = temp; &#125; void permutation(char *str, int start, int end) // 递归生成全排列 &#123; if (start == end) // 如果只有一个字符，直接输出 &#123; printf(&quot;%s\\n&quot;, str); &#125; else &#123; for (int i = start; i &lt;= end; i++) // 枚举每个位置 &#123; swap(&amp;str[start], &amp;str[i]); // 将当前位置和后面的位置交换 permutation(str, start + 1, end); // 递归处理剩余的位置 swap(&amp;str[start], &amp;str[i]); // 回溯时恢复原来的顺序 &#125; &#125; &#125; int main() &#123; char *str = strdup(&quot;abc&quot;); // 输入的字符串 int len = strlen(str); // 字符串长度 if (len &gt; 0) // 如果字符串不为空 &#123; permutation(str, 0, len - 1); // 从第0个位置到最后一个位置生成全排列 &#125; free(str); // 释放内存 return 0; &#125; 运行结果 acb bac bca cba cab 用 strdup 函数，有什么好处？ strdup 函数的作用是将一个字符串的内容复制到另一个字符串上，并返回一个指向新字符串的指针。使用 strdup 函数有以下好处： 可以避免修改原始字符串，因为新字符串有自己的内存空间。 可以动态分配内存，不需要提前知道字符串的长度。 可以方便地释放内存，只需要调用 free 函数即可。 但是，使用 strdup 函数也要注意以下问题： strdup 函数的参数不能为 NULL，否则会报段错误。 strdup 函数可能会失败，返回 NULL，所以要检查返回值是否有效。 strdup 函数不是标准库函数，而是 POSIX 扩展函数，所以在一些平台上可能不可用。","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"author":"yuhiri"},{"title":"gitalk 评论","slug":"gitalk-评论","date":"2023-03-23T10:28:52.000Z","updated":"2026-01-05T13:46:05.676Z","comments":true,"path":"2023/03/23/gitalk-评论/","permalink":"http://yuhiri.me/2023/03/23/gitalk-%E8%AF%84%E8%AE%BA/","excerpt":"","text":"gitalk 配置好了， 耶！有评论了！！！ヾ(≧∇≦*)ゝ","categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yuhiri.me/tags/%E6%9D%82%E8%B0%88/"}],"author":"yuhiri"},{"title":"Web前端笔记--Emmet","slug":"Web前端笔记-Emmet","date":"2023-03-09T15:05:49.000Z","updated":"2026-01-05T13:43:08.923Z","comments":true,"path":"2023/03/09/Web前端笔记-Emmet/","permalink":"http://yuhiri.me/2023/03/09/Web%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0-Emmet/","excerpt":"","text":"Web前端笔记（更新） web 前端笔记已更新 查看地址：https://lib.yuhiri.me/codenotes/web/","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yuhiri.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Note","slug":"Note","permalink":"http://yuhiri.me/tags/Note/"},{"name":"Web","slug":"Web","permalink":"http://yuhiri.me/tags/Web/"}],"author":"yuhiri"},{"title":"《Python编程：从入门到实践（第2版）》","slug":"《Python编程：从入门到实践（第2版）》","date":"2023-03-08T13:49:06.000Z","updated":"2026-01-05T13:48:39.258Z","comments":true,"path":"2023/03/08/《Python编程：从入门到实践（第2版）》/","permalink":"http://yuhiri.me/2023/03/08/%E3%80%8APython%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89%E3%80%8B/","excerpt":"","text":"《Python编程：从入门到实践（第2版）》 获取链接：https://www.aliyundrive.com/s/x3bWWMBeThg 图书简介 受父亲影响，5 岁的埃里克·马瑟斯开始编写自己的第一个程序—— 一个简单的猜数字游戏。从孩童时期开始，编程带给马瑟斯的满足感一直影响至今。30 岁时，作为 Python 爱好者，他开始在技术社区中义务教授 Python。源于对 Python 的好奇心，他的儿子 Ever 每天不断提问，这才驱使他有了写作本书的想法。所以，与其说它是一本书，倒不如说它是对父子两代人编程初心的传承。 英文书名进一步阐述了本书的意图，PythonCrashCourse:AHands-On,Project-BasedIntroductiontoProgramming 直译过来的意思是“Python 速成教程：动手操作、基于项目的编程入门”。从书名来看，它并不是真正意义上的教材。与大学计算机系的正统编程语言教材相比，它最大的不同点在于：实践为主（hands-on）项目为纲（project-based）如今，随着互联网产业的高速发展，在网络上早已积累了极其丰富的 Python 学习资料，任何人都可以基于这些资源，自学掌握 Python。但实际上，网络上充斥的资源太多、太杂且不成体系，在没有足够的编程/工程经验之前，仅靠“看”线上资源自学，的确是一件非常困难的事。 当年，大妈自己光是开发第一个实用工具（一个不超过 50 行代码的项目），就前后用了将近半年的时间才得以成功。之所以耗时这么久，原因在于：官方文档/教程过大、过全，学习曲线陡峭，更适合有经验的软件工程师；面向初学者的教程只讲基础语法，并没有关于项目的实践引导。20 多年过去了，市面上一直不乏各种教授“零基础入门 Python”的图书，但至今只有两本摸到了门径。一本是《笨办法学Python》 ，通过极其精练的针对性练习，帮助小白突破对编程的恐惧，但遗憾的是，它并没有包含如何完成实用工程的内容。另外一本，就是这本“Python蟒蛇书” 。得益于中学老师的身份，作者平时接触的都是非计算机专业的学生。他结合自己的教学经历，撰写了这本从零开始快速上手 Python 的好书。更令人兴奋的是，为了拥抱 Python 技术生态的变化，作者及时增补了第 2 版，替换和追加了很多常用模块/框架/工具的介绍，整体上更贴近实际开发环境。不过，从大妈的经验来看，完全无基础的读者最好别从第 1 章开始学习，否则在第一部分就会耗尽所有热情。 这里，我建议大家 ： 第一部分尽可能在 42 小时内快速浏览一遍，不用理解，先混个眼熟； 第二部分跟着项目实践精读，对应查阅第一部分的基础知识点，针对性地自我答 疑。 这样，你就能从枯燥的语法、控制结构、数据结构等无穷的编程概念中挣脱出来，进入一个个具体真实的项目场景中，一切将变得异常清晰、有目标且可检验。当然，最好还是能找到一起学习的小伙伴，无论是线下共读，还是线上远程协同。总之，大家一起折腾，阅读和学习才可能事半功倍。最后，我想说，Python 是否值得学，已经不再是值得怀疑的问题了（特别是在人类于2018 年用 Python 合成首张黑洞照片之后）。但是，如何能高效学会 Python，永远是个值得思考的重要问题。这个问题的答案，是绕不开本书的。 大妈/ZoomQuiet，CPyUG 联合创始人、蟒营® 创始人 在线资源 要获取以下补充材料，可访问 https://www.ituring.com.cn/book/2784 安装说明 ：与书中的安装说明相同，但可直接点击其中的链接，无须动手输入。遇到安装问题时，可参阅这些材料。 更新 ：与其他编程语言一样，Python 也是在不断发展变化的。我提供了详尽的更新记录，每当遇到问题时，你都可参阅它看看是否需要调整操作。 练习答案 ：你应该花大量时间独立完成“动手试一试”中的练习，但如果卡壳了、无法取得进展，可在线查看部分练习的答案。 速查表 ：在线提供了完整的速查表，可作为主要概念的参考指南。","categories":[{"name":"资源","slug":"资源","permalink":"http://yuhiri.me/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"http://yuhiri.me/tags/%E6%82%A6%E8%AF%BB/"}],"author":"yuhiri"},{"title":"为水而水（笑","slug":"为水而水（笑","date":"2023-02-07T13:53:10.000Z","updated":"2026-01-05T13:47:55.688Z","comments":true,"path":"2023/02/07/为水而水（笑/","permalink":"http://yuhiri.me/2023/02/07/%E4%B8%BA%E6%B0%B4%E8%80%8C%E6%B0%B4%EF%BC%88%E7%AC%91/","excerpt":"","text":"Hi! There is Talentestors!ヾ(≧∇≦*)ゝ Platform&amp;Tools Console&amp;Game Genshin github：https://github.com/talentestors","categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"划水","slug":"划水","permalink":"http://yuhiri.me/tags/%E5%88%92%E6%B0%B4/"}],"author":"yuhiri"},{"title":"书籍资源","slug":"书籍资源","date":"2023-02-06T04:58:23.000Z","updated":"2026-01-05T13:48:01.887Z","comments":true,"path":"2023/02/06/书籍资源/","permalink":"http://yuhiri.me/2023/02/06/%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%BA%90/","excerpt":"","text":"资源名称 分享链接 《Labuladong的算法小抄》 https://www.aliyundrive.com/s/8hBDqmWUe4w 《小傅哥的IDEA插件开发手册》 https://www.aliyundrive.com/s/sbQFgXVdXJx 《疯狂Java讲义第四版》 https://www.aliyundrive.com/s/vVCCKcDmQss 《Java核心技术卷1、2》 https://www.aliyundrive.com/s/FNdsboNYehT 《Linux命令速查手册》 https://www.aliyundrive.com/s/u95LqoybqPK 《鸟哥的Linux私房菜-高清》 https://www.aliyundrive.com/s/VD3xcbfj9Ca 《数学建模算法与应用-第二版-司守奎》 https://www.aliyundrive.com/s/VD3xcbfj9Ca 《统计学习方法-李航》 https://www.aliyundrive.com/s/VD3xcbfj9Ca 《Matlab神经网络30个案例分析》 https://www.aliyundrive.com/s/MDahYPF2Kwr 《具有AI功能加持的终端工具warp使用总结》 https://www.aliyundrive.com/s/MDahYPF2Kwr 一键获取 提取码:38cr","categories":[{"name":"资源","slug":"资源","permalink":"http://yuhiri.me/categories/%E8%B5%84%E6%BA%90/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"http://yuhiri.me/tags/%E6%82%A6%E8%AF%BB/"}],"author":"yuhiri"},{"title":"C语言链表","slug":"C语言链表","date":"2023-02-06T04:45:34.000Z","updated":"2026-01-05T13:46:44.333Z","comments":true,"path":"2023/02/06/C语言链表/","permalink":"http://yuhiri.me/2023/02/06/C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/","excerpt":"","text":"C语言链表 代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef int E; /*It stands for shaping element*/ struct ListNode &#123; E element; struct ListNode * next; /*保存下一个节点的地址*/ &#125;; typedef struct ListNode * Node; /*将“ListNode *&quot;命名为”Node“*/ /** * 初始化链表 * @param node 传入头结点指针 */ void initList(Node node)&#123; node-&gt;next = NULL; &#125; /** * 计算链表的节点数不计头结点 * @param head 传入头结点指针 * @return 返回节点数目 */ int sizeList(Node head)&#123; int i = -1; while (head) &#123; head = head-&gt;next; i++; &#125; return i; &#125; /** * 随机位置插入节点 * @param head 传入头结点指针 * @param element 传入新节点的元素 * @param index 传入插入位置 * @return 位置不合法或插入失败返回0，成功返回1 */ _Bool insertList(Node head,E element,int index)&#123; if (index &lt; 1) return 0; while (--index) &#123; head = head-&gt;next; if (head == NULL) return 0; &#125; Node node = malloc(sizeof(struct ListNode)); if(node == NULL) return 0; //创建一个新的结点，如果内存空间申请失败返回0 node-&gt;element = element; node-&gt;next = head-&gt;next; head-&gt;next = node; //接着将前驱结点指向新的这个结点 return 1; &#125; /** * 头插：在头结点后插入新节点 * @param head 传入头结点指针 * @param data 传入新节点的元素 * @return 插入失败返回0，成功返回1 */ _Bool InsertToHead(Node head, E data) &#123; if (insertList(head, data, 1)) return 1; return 0; &#125; /** * 尾插：在尾结点后插入新节点 * @param head 传入头结点指针 * @param data 传入新节点的元素 * @return 插入失败返回0，成功返回1 */ _Bool InsertToTail(Node head, int data) &#123; if (insertList(head, data, sizeList(head) + 1)) return 1; return 0; &#125; /** * 删除指定节点 * @param head 传入头结点指针 * @param index 传入删除节点的位置 * @return 位置不合法或结点异常返回0，成功返回1 */ _Bool deleteList(Node head, int index)&#123; if(index &lt; 1) return 0; //大体和上面是一样的 while (--index) &#123; head = head-&gt;next; if(head == NULL) return 0; &#125; if(head-&gt;next == NULL) return 0; Node tmp = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; free(tmp); return 1; &#125; /** * 修改元素 * @param head 传入头结点指针 * @param index 传入修改节点的位置 * @param change 元素的新值 * @return 位置不合法或结点异常返回0，成功返回1 */ _Bool SetElement(Node head, int index, E change) &#123; if (index &lt; 1) &#123; printf(&quot;no exist!\\n&quot;); return 0; &#125; while (--index) &#123; head = head-&gt;next; if (head == NULL) &#123; printf(&quot;no exist!\\n&quot;); return 0; &#125; &#125; head-&gt;next-&gt;element = change; return 1; &#125; /** * 获取元素的值 * @param head 传入头结点指针 * @param index 传入获取节点元素的位置 * @return 返回这个元素 */ E * getList(Node head, int index)&#123; if(index &lt; 1) return 0; do &#123; head = head-&gt;next; if(head == NULL) return 0; &#125; while (--index); return &amp;head-&gt;element; &#125; /** * 查找元素，获取前驱节点 * @param head 传入头结点指针 * @param target 查找目标 * @return 目标的前驱节点 */ Node SearchLink_Pointer(Node head, int target) &#123; while (head-&gt;next != NULL &amp;&amp; target &gt; 0) &#123; head = head-&gt;next; target--; &#125; return head; &#125; /** * 查找元素，获取节点的位置 * @param head 传入头结点指针 * @param element 查找目标 * @return 节点的位置 */ int findList(Node head, E element)&#123; head = head-&gt;next; int i = 1; while (head) &#123; if(head-&gt;element == element) return i; head = head-&gt;next; i++; &#125; return -1; &#125; /** * 对链表进行冒泡排序 * @param head 传入头结点指针 * @param length 传入链表的长度（不包括头结点） */ void sortLink_B(Node head,int length)&#123; int temp; for (int i = 0; i &lt; length; ++i) &#123; _Bool flag = 1; Node node = head-&gt;next; while (head -&gt; next != NULL) &#123; if (head-&gt;element &gt; head-&gt;next-&gt;element) &#123; temp = head-&gt;element; head-&gt;element = head-&gt;next-&gt;element; head-&gt;next-&gt;element = temp; flag = 0; &#125; head = head-&gt;next; &#125; if (flag) break; else head = node; &#125; &#125; /** * 打印链表 * @param head 传入头结点指针 */ void printList(Node head)&#123; while (head-&gt;next) &#123; head = head-&gt;next; printf(&quot;%d &quot;, head-&gt;element); //因为头结点不存放数据，所以从第二个开始打印 &#125; printf(&quot;\\n&quot;); &#125; /** * 链表元素交换 * @param head 传入头结点指针 * @param index1 待交换的节点位置 * @param index2 待交换的节点位置 */ void SwapLink(Node head,int index1,int index2)&#123; Node temp1, temp2; temp1 = SearchLink_Pointer(head, index1); temp2 = SearchLink_Pointer(head, index2); int tmp = temp1-&gt;element; temp1-&gt;element = temp2-&gt;element; temp2-&gt;element = tmp; &#125; Test int main()&#123; struct ListNode head; initList(&amp;head); for (int i = 1; i &lt;= 10; ++i) &#123; insertList(&amp;head, i * 100, i); &#125; printList(&amp;head); deleteList(&amp;head,4); SetElement(&amp;head,4,666); printList(&amp;head); printf(&quot;%d\\n&quot;, *getList(&amp;head,3)); printf(&quot;%d\\n&quot;, findList(&amp;head,100)); printf(&quot;%d\\n&quot;, sizeList(&amp;head)); SwapLink(&amp;head,2,5); printList(&amp;head); sortLink_B(&amp;head, sizeList(&amp;head)); printList(&amp;head); &#125; 结果 作者本人，移植于CSDN 原文链接：https://blog.csdn.net/m0_44950849/article/details/128152853 于 2022-12-02 18:53:48 发布CSDN","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"author":"yuhiri"},{"title":"力扣新手村题412. Fizz Buzz C语言","slug":"力扣新手村题412-Fizz-Buzz-C语言","date":"2023-02-06T04:36:27.000Z","updated":"2026-01-05T13:48:06.039Z","comments":true,"path":"2023/02/06/力扣新手村题412-Fizz-Buzz-C语言/","permalink":"http://yuhiri.me/2023/02/06/%E5%8A%9B%E6%89%A3%E6%96%B0%E6%89%8B%E6%9D%91%E9%A2%98412-Fizz-Buzz-C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"412. Fizz Buzz 力扣链接:Fizz Buzz 给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中： answer[i] == &quot;FizzBuzz&quot;如果 i 同时是 3 和 5 的倍数。 answer[i] == &quot;Fizz&quot; 如果 i 是 3 的倍数。 answer[i] == &quot;Buzz&quot; 如果 i 是 5 的倍数。 answer[i] == i （以字符串形式）如果上述条件全不满足。 示例 1： 输入：n = 3 输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;] 示例 2： 输入：n = 5 输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;] 示例 3： 输入：n = 15 输出：[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;] 提示： 1 &lt;= n &lt;= 104 代码实现 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; char ** fizzBuzz(int n, int* returnSize)&#123; *returnSize = n;//必须加的部分，表示数组的元素个数 //不加LeetCode无法输出结果 /*最重要的部分，需要对二级指针有一定的理解*/ char **pChar = (char ** )malloc(n * sizeof(char *));/*等同于char *p[n];指针数组*/ for (int i = 0; i &lt; n; ++i) *(pChar+i) = (char * ) malloc(sizeof(char)*9); for (int i = 1; i &lt;= n; ++i) &#123; if (i % 15 == 0) pChar[i-1] = &quot;FizzBuzz&quot;; else if (i % 3 == 0) pChar[i-1] = &quot;Fizz&quot;; else if (i % 5 == 0) pChar[i-1] = &quot;Buzz&quot;; else sprintf(pChar[i-1],&quot;%d&quot;,i); &#125; return pChar; &#125; 分析： 该题最重要的是如何使用二级指针，动态分配二维Char数组 知识点 sprintf函数 sprintf指的是字符串格式化命令,主要功能是把格式化的数据写入某个字符串中 sprintf原型 int sprintf (char *__restrict, const char *__restrict, ...) _ATTRIBUTE ((__format__ (__printf__, 2, 3))); 在本题中主要解决整数的传入字符串的问题 sprintf(pChar[i-1],&quot;%d&quot;,i); //不要把一个整数对应一个“%s” 优点 简单方便 可以格式化给字符串赋值 可对写入字符数做出限制，防止buffer溢出 返回值 如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。 总结 ：题目简单，只有二级指针和sprintf函数两个点 适合初学者巩固基础 作者本人，移植于CSDN 原文链接：https://blog.csdn.net/m0_44950849/article/details/128112092 于 2022-11-30 12:14:42 发布CSDN","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yuhiri.me/tags/LeetCode/"}],"author":"yuhiri"},{"title":"sublime text 3 运行+运行java＜控制台＞","slug":"sublime-text-3-运行-运行java＜控制台＞","date":"2023-02-05T04:26:09.000Z","updated":"2026-01-05T13:43:50.396Z","comments":true,"path":"2023/02/05/sublime-text-3-运行-运行java＜控制台＞/","permalink":"http://yuhiri.me/2023/02/05/sublime-text-3-%E8%BF%90%E8%A1%8C-%E8%BF%90%E8%A1%8Cjava%EF%BC%9C%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%9E/","excerpt":"","text":"平台：Windows 1.安装好jdk（8 or 11），并且配置好环境变量 2.找到 工具—&gt;编译系统—&gt;新编译系统 ps：英文版为；Tools—&gt;Build system—&gt;New Build system 3.输入以下代码 &#123; &quot;shell&quot;: true, &quot;cmd&quot;: [&quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;javac -encoding UTF-8 $&#123;file&#125; &amp; java $&#123;file_base_name&#125; &amp;echo. &amp; pause &quot;], &quot;file_regex&quot; :&quot;^(...*?):([0-9]*):?([0-9]*)&quot;, &quot;selector&quot; :&quot;source.java&quot;, &quot;shell&quot; :true, &quot;working_dir&quot;:&quot;$&#123;file_path&#125;&quot;, &quot;encoding&quot; :&quot;GBK&quot;, &#125; 4.保存至C:\\Users********\\AppData\\Roaming\\Sublime Text 3\\Packages\\User ​ 文件名为：runjava.sublime-build 5.在sublime内找到 工具—&gt;编译系统—&gt;runjava ​ 按 Ctrl + b 就能生成class文件并运行 还可以参照其他方法（链接如下）： Sublime Text3配置Java环境-升级版_DE2-115的博客-CSDN博客_sublime text3 配置java sublime text3运行java程序_不豫的博客-CSDN博客_sublime text3写java sublime text 3 运行java_无名虫的博客-CSDN博客_sublime text 运行java Sublime Text 3编译运行java源代码方法_故事如烟的博客-CSDN博客 作者本人，移植于CSDN 原文链接：https://blog.csdn.net/m0_44950849/article/details/125392979 于 2022-06-21 16:23:29 发布CSDN","categories":[{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://yuhiri.me/tags/%E8%BD%AF%E4%BB%B6/"}],"author":"yuhiri"},{"title":"My first blog","slug":"My-first-blog","date":"2023-02-05T03:58:31.000Z","updated":"2026-01-05T13:44:49.274Z","comments":true,"path":"2023/02/05/My-first-blog/","permalink":"http://yuhiri.me/2023/02/05/My-first-blog/","excerpt":"","text":"My first blog Hi！ Here’s “talentestors” This is my first blog. ヾ(≧∇≦*)ゝ My Github: https://github.com/talentestors My Gitee: https://gitee.com/talentestors Console&amp;Game Genshin","categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yuhiri.me/tags/blog/"},{"name":"web","slug":"web","permalink":"http://yuhiri.me/tags/web/"}],"author":"yuhiri"}],"categories":[{"name":"随想","slug":"随想","permalink":"http://yuhiri.me/categories/%E9%9A%8F%E6%83%B3/"},{"name":"技术","slug":"技术","permalink":"http://yuhiri.me/categories/%E6%8A%80%E6%9C%AF/"},{"name":"资源","slug":"资源","permalink":"http://yuhiri.me/categories/%E8%B5%84%E6%BA%90/"},{"name":"转载","slug":"转载","permalink":"http://yuhiri.me/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"开源","slug":"开源","permalink":"http://yuhiri.me/tags/%E5%BC%80%E6%BA%90/"},{"name":"云计算","slug":"云计算","permalink":"http://yuhiri.me/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"服务器运维","slug":"服务器运维","permalink":"http://yuhiri.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"},{"name":"Python","slug":"Python","permalink":"http://yuhiri.me/tags/Python/"},{"name":"NoneBot","slug":"NoneBot","permalink":"http://yuhiri.me/tags/NoneBot/"},{"name":"职业发展","slug":"职业发展","permalink":"http://yuhiri.me/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"},{"name":"技术总结","slug":"技术总结","permalink":"http://yuhiri.me/tags/%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"},{"name":"DDoS","slug":"DDoS","permalink":"http://yuhiri.me/tags/DDoS/"},{"name":"CC攻击","slug":"CC攻击","permalink":"http://yuhiri.me/tags/CC%E6%94%BB%E5%87%BB/"},{"name":"网络安全","slug":"网络安全","permalink":"http://yuhiri.me/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"OSINT","slug":"OSINT","permalink":"http://yuhiri.me/tags/OSINT/"},{"name":"开源情报","slug":"开源情报","permalink":"http://yuhiri.me/tags/%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5/"},{"name":"信息分析","slug":"信息分析","permalink":"http://yuhiri.me/tags/%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90/"},{"name":"隐私伦理","slug":"隐私伦理","permalink":"http://yuhiri.me/tags/%E9%9A%90%E7%A7%81%E4%BC%A6%E7%90%86/"},{"name":"数据合规","slug":"数据合规","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E5%90%88%E8%A7%84/"},{"name":"C++","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"RVO","slug":"RVO","permalink":"http://yuhiri.me/tags/RVO/"},{"name":"408","slug":"408","permalink":"http://yuhiri.me/tags/408/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yuhiri.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yuhiri.me/tags/GitHub/"},{"name":"README","slug":"README","permalink":"http://yuhiri.me/tags/README/"},{"name":"LICENSE","slug":"LICENSE","permalink":"http://yuhiri.me/tags/LICENSE/"},{"name":"CONTRIBUTING","slug":"CONTRIBUTING","permalink":"http://yuhiri.me/tags/CONTRIBUTING/"},{"name":"仓库管理","slug":"仓库管理","permalink":"http://yuhiri.me/tags/%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86/"},{"name":"题解","slug":"题解","permalink":"http://yuhiri.me/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://yuhiri.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"CodeForces","slug":"CodeForces","permalink":"http://yuhiri.me/tags/CodeForces/"},{"name":"Div3","slug":"Div3","permalink":"http://yuhiri.me/tags/Div3/"},{"name":"C/CPP","slug":"C-CPP","permalink":"http://yuhiri.me/tags/C-CPP/"},{"name":"Java","slug":"Java","permalink":"http://yuhiri.me/tags/Java/"},{"name":"Lombok","slug":"Lombok","permalink":"http://yuhiri.me/tags/Lombok/"},{"name":"Gradle","slug":"Gradle","permalink":"http://yuhiri.me/tags/Gradle/"},{"name":"GitHub Actions","slug":"GitHub-Actions","permalink":"http://yuhiri.me/tags/GitHub-Actions/"},{"name":"课程","slug":"课程","permalink":"http://yuhiri.me/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"blacklist","slug":"blacklist","permalink":"http://yuhiri.me/tags/blacklist/"},{"name":"Comment","slug":"Comment","permalink":"http://yuhiri.me/tags/Comment/"},{"name":"giscus","slug":"giscus","permalink":"http://yuhiri.me/tags/giscus/"},{"name":"gitalk","slug":"gitalk","permalink":"http://yuhiri.me/tags/gitalk/"},{"name":"utteranc","slug":"utteranc","permalink":"http://yuhiri.me/tags/utteranc/"},{"name":"应用","slug":"应用","permalink":"http://yuhiri.me/tags/%E5%BA%94%E7%94%A8/"},{"name":"Div2","slug":"Div2","permalink":"http://yuhiri.me/tags/Div2/"},{"name":"JDK","slug":"JDK","permalink":"http://yuhiri.me/tags/JDK/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yuhiri.me/tags/Tomcat/"},{"name":"乱码","slug":"乱码","permalink":"http://yuhiri.me/tags/%E4%B9%B1%E7%A0%81/"},{"name":"编码","slug":"编码","permalink":"http://yuhiri.me/tags/%E7%BC%96%E7%A0%81/"},{"name":"字符集","slug":"字符集","permalink":"http://yuhiri.me/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"输出流","slug":"输出流","permalink":"http://yuhiri.me/tags/%E8%BE%93%E5%87%BA%E6%B5%81/"},{"name":"UTF-8","slug":"UTF-8","permalink":"http://yuhiri.me/tags/UTF-8/"},{"name":"PrintStream","slug":"PrintStream","permalink":"http://yuhiri.me/tags/PrintStream/"},{"name":"编程技巧","slug":"编程技巧","permalink":"http://yuhiri.me/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"},{"name":"STL","slug":"STL","permalink":"http://yuhiri.me/tags/STL/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yuhiri.me/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"网络流","slug":"网络流","permalink":"http://yuhiri.me/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"Dinic","slug":"Dinic","permalink":"http://yuhiri.me/tags/Dinic/"},{"name":"图论","slug":"图论","permalink":"http://yuhiri.me/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Linux","slug":"Linux","permalink":"http://yuhiri.me/tags/Linux/"},{"name":"镜像源","slug":"镜像源","permalink":"http://yuhiri.me/tags/%E9%95%9C%E5%83%8F%E6%BA%90/"},{"name":"tools","slug":"tools","permalink":"http://yuhiri.me/tags/tools/"},{"name":"随机增量法","slug":"随机增量法","permalink":"http://yuhiri.me/tags/%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F%E6%B3%95/"},{"name":"二分套二分","slug":"二分套二分","permalink":"http://yuhiri.me/tags/%E4%BA%8C%E5%88%86%E5%A5%97%E4%BA%8C%E5%88%86/"},{"name":"Web","slug":"Web","permalink":"http://yuhiri.me/tags/Web/"},{"name":"CSS","slug":"CSS","permalink":"http://yuhiri.me/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuhiri.me/tags/JavaScript/"},{"name":"Color","slug":"Color","permalink":"http://yuhiri.me/tags/Color/"},{"name":"cloudflare","slug":"cloudflare","permalink":"http://yuhiri.me/tags/cloudflare/"},{"name":"Rocket Loader","slug":"Rocket-Loader","permalink":"http://yuhiri.me/tags/Rocket-Loader/"},{"name":"线段树","slug":"线段树","permalink":"http://yuhiri.me/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"新年","slug":"新年","permalink":"http://yuhiri.me/tags/%E6%96%B0%E5%B9%B4/"},{"name":"C/C++","slug":"C-C","permalink":"http://yuhiri.me/tags/C-C/"},{"name":"VSCode","slug":"VSCode","permalink":"http://yuhiri.me/tags/VSCode/"},{"name":"MSYS2","slug":"MSYS2","permalink":"http://yuhiri.me/tags/MSYS2/"},{"name":"萌新","slug":"萌新","permalink":"http://yuhiri.me/tags/%E8%90%8C%E6%96%B0/"},{"name":"__builtin__","slug":"builtin","permalink":"http://yuhiri.me/tags/builtin/"},{"name":"Swing","slug":"Swing","permalink":"http://yuhiri.me/tags/Swing/"},{"name":"C语言","slug":"C语言","permalink":"http://yuhiri.me/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"CPP","slug":"CPP","permalink":"http://yuhiri.me/tags/CPP/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yuhiri.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"vue","slug":"vue","permalink":"http://yuhiri.me/tags/vue/"},{"name":"笔记","slug":"笔记","permalink":"http://yuhiri.me/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Note","slug":"Note","permalink":"http://yuhiri.me/tags/Note/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yuhiri.me/tags/LeetCode/"},{"name":"C","slug":"C","permalink":"http://yuhiri.me/tags/C/"},{"name":"划水","slug":"划水","permalink":"http://yuhiri.me/tags/%E5%88%92%E6%B0%B4/"},{"name":"包管理器","slug":"包管理器","permalink":"http://yuhiri.me/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"Scoop","slug":"Scoop","permalink":"http://yuhiri.me/tags/Scoop/"},{"name":"软件","slug":"软件","permalink":"http://yuhiri.me/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"杂谈","slug":"杂谈","permalink":"http://yuhiri.me/tags/%E6%9D%82%E8%B0%88/"},{"name":"悦读","slug":"悦读","permalink":"http://yuhiri.me/tags/%E6%82%A6%E8%AF%BB/"},{"name":"blog","slug":"blog","permalink":"http://yuhiri.me/tags/blog/"},{"name":"web","slug":"web","permalink":"http://yuhiri.me/tags/web/"}]}